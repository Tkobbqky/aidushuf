机械工业出版社Java核心技术系列JAVA高并发编程详解:多线程与架构设计 PDF下载 汪文君 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711159993
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711159993
<p>书名:机械工业出版社Java核心技术系列JAVA高并发编程详解:多线程与架构设计</p><p>作者:汪文君</p><p>页数:379</p><p>定价:¥89.0</p><p>出版社:机械工业出版社</p><p>出版日期:2017-06-01</p><p>ISBN:9787111599937</p><p><h2>相关资料</h2></p>[<p>
汪文君老师一直是我敬佩和学习的楷模。十年之前，我在公司认识了新来的长发少年汪文君同学，至今依然记得文君他对人热情，对于工作、生活中接触的各种事物都充满了好奇心，总是在热情高涨地学习新技术，他每天晚上都会拿出时间学习，很多节假日也都抽出专门的时间来学习和编程。本书围绕Java编程中多线程编程的基础与应用设计分为四个部分来展开讲解，包括多线程技术知识、Java
ClassLoader、深入理解volatile关键字、多线程设计架构模式。通过这本书的学习，我们能够更全面地拓展自己的编程能力，更进一步地充实编程设计和架构设计的系统性思维。
——东软集团移动互联网事业部首席技术官  徐景辉
 
汪文君是我们软件开发团队里特别有朝气的一员，平时不管是工作还是业余时间，其都会对软件开发遇到的难题、专题进行不折不挠的攻关研究，他是团队所有人心目中的技术大牛。我作为部门主管，从三个月前得知他开始写这本书时，就特别期待，之前他利用业余时间录制网上视频供大家学习与交流，现在他把这些知识再加以整理出版成书，相信他的所作所为能让许多人受益。
——Head of Data Engineering at
HSBC  Winne Chen
 
我与汪文君共事过几年，我们负责的是全球性交易系统，对系统性能的要求极高。他是团队里的技术骨干，在我们共事的日子里，汪文君解决了很多技术难题，更难能可贵的是，汪文君在设计阶段就敏捷地洞察到系统可能会出现的瓶颈并且提供解决方案，而且每一个点子，每一个难题的解决之道，他都极富激情地分享给团队的所有成员。得知他要写本Java多线程的书，有幸试读了其中一些章节，感觉特别棒，他能将每一个Java多线程相关的话题都讲解得很有深度。在整本书的构想方面，各个章节的内聚性都很强，章节与章节之间又是层层推进的关系，再加以精准的图示辅助理解，让读者阅读起来感觉非常舒服。本书中所讲解的都是一个个的实战运用，对提升Java内功必然大有裨益。
——Development manager at HSBC
Global Banking and Markets  Bonson zheng
</p>]<p><h2>本书特色</h2></p>[<p>
本书主要包含四个部分：<br/>*部分主要阐述Thread的基础知识，详细介绍线程的API使用、线程安全、线程间数据通信，以及如何保护共享资源等内容，它是深入学习多线程内容的基础。<br/>第二部分引入了ClassLoader，这是因为ClassLoader与线程不无关系，我们可以通过synchronized关键字，或者Lock等显式锁的方式在代码的编写阶段对共享资源进行数据一致性保护，那么一个Class在完成初始化的整个过程到*后在方法区（JDK8 以后在元数据空间）其数据结构是怎样确保数据一致性的呢？这就需要对ClassLoader有一个比较全面的认识和了解。<br/>第三部分详细、深入地介绍volatile关键字的语义，volatile关键字在Java中非常重要，可以说它奠定了Java核心并发包的高效运行，在这一部分中，我们通过实例展示了如何使用volatile关键字以及非常详细地介绍了Java内存模型等知识。<br/>本书的第四部分，站在程序架构设计的角度深入讲解了如何设计高效灵活的多线程应用程序，这一部分长达15个章节，其重要程度可见一斑。<br/>本书主要包含四个部分：
*部分主要阐述Thread的基础知识，详细介绍线程的API使用、线程安全、线程间数据通信，以及如何保护共享资源等内容，它是深入学习多线程内容的基础。
第二部分引入了ClassLoader，这是因为ClassLoader与线程不无关系，我们可以通过synchronized关键字，或者Lock等显式锁的方式在代码的编写阶段对共享资源进行数据一致性保护，那么一个Class在完成初始化的整个过程到*后在方法区（JDK8 以后在元数据空间）其数据结构是怎样确保数据一致性的呢？这就需要对ClassLoader有一个比较全面的认识和了解。
第三部分详细、深入地介绍volatile关键字的语义，volatile关键字在Java中非常重要，可以说它奠定了Java核心并发包的高效运行，在这一部分中，我们通过实例展示了如何使用volatile关键字以及非常详细地介绍了Java内存模型等知识。
本书的第四部分，站在程序架构设计的角度深入讲解了如何设计高效灵活的多线程应用程序，这一部分长达15个章节，其重要程度可见一斑。 

                                        </p>]<p><h2>内容简介</h2></p>[<p>本书共分为四个部分：部分详细地介绍了Java多线程的基本用法和各个API的使用，并且着重介绍了线程与Java虚拟机内存之间的关系。第二部分由线程上下文类加载器方法引入，介绍为什么在线程中要有上下文类加载器的方法函数，从而掌握类在JVM的加载和初始化的整个过程。第三部分主要围绕着volatile关键字展开，在该部分中我们将会了解到现代CPU的架构以及Java的内存模型（JMM）。后一部分，主要站在架构设计的高度看待如何巧妙地开发出真正具备并发能力的系统。</p>]<p><h2>作者简介</h2></p>[<p>
汪文君
汇丰软件（广东）研发中心数据服务中心技术经理、技术专家，目前专注于实时数据data pipeline平台的构建与架构，在加入汇丰软件以前，曾有5年多的移动通讯工作经验，以及移动互联网、云计算和B2C电子商务平台的开发架构经验，热衷于技术分享、技术细节锤炼。目前已录制10余套技术视频，在互联网上广泛传播。
</p>]<p><h2>目录</h2></p>
    **部分：多线程基础       20
第1章：快速认识线程       22
1.1 线程的介绍    22
1.2 快速创建并启动一个线程    22
1.2.1 尝试并行运行     23
1.2.2 并发运行交替输出     24
1.2.3 使用Jconsole观察线程      25
1.3 线程的生命周期详解    26
1.3.1 线程的NEW状态      27
1.3.2 线程的RUNNABLE状态  28
1.3.3 线程的 RUNNING状态    28
1.3.4 线程的BLOCKED状态     29
1.3.5 线程的TERMINATED状态      29
1.4 线程的start方法剖析--模板设计模式在Thread中的应用 30
1.4.1 Thread
start方法源码分析以及注意事项  30
1.4.2 模板设计模式在Thread中的应用    33
1.4.3 Thread模拟营业大厅叫号机程序      34
1.5 Runnable接口的引入以及策略模式在Thread中的使用    39
1.5.1 Runnable的职责  39
1.5.2 策略模式在Thread中的应用    40
1.5.3 模拟营业大厅叫号机程序  42
1.6 本章总结 43
第2章：深入理解Thread构造函数   45
2.1 线程的命名    45
2.1.1 线程的默认命名  45
2.1.2 命名线程     46
2.1.3 修改线程的名字  47
2.2 线程的父子关系    48
2.3 Thread与ThreadGroup   48
2.4 Thread与Runnable  50
2.5 Thread与JVM虚拟机栈       50
2.5.1 Thread与Stacksize      51
2.5.2 JVM内存结构     53
2.5.3 Thread与虚拟机栈      58
2.6 守护线程 62
2.6.1 什么是守护线程  62
2.6.2 守护线程的作用  64
2.7 本章总结 64
第3章：Thread API的详细介绍 66
3.1 线程sleep       66
3.1.1 sleep方法介绍     66
3.1.2 使用TimeUnit替代Thread.sleep       67
3.2 线程yield       68
3.2.1 yield方法介绍     68
3.2.2 yield vs
sleep 69
3.3 设置线程的优先级 69
3.3.1 线程优先级介绍  70
3.3.2 线程优先级源码分析  71
3.3.3 关于优先级的一些总结     72
3.4 获取线程ID   73
3.5 获取当前线程 73
3.6 设置线程上下文类加载器    74
3.7 线程interrupt  75
3.7.1 interrupt 75
3.7.2
isInterrupted  77
3.7.3
interrupted    79
3.7.4 interrupt注意事项       81
3.8 线程join  82
3.8.1 线程join方法详解     83
3.8.2 join方法结合实战       85
3.9 如何关闭一个线程 90
3.9.1 正常关闭     90
3.9.2 异常退出     94
3.9.3 进程假死     94
3.10 本章总结      95
第4章：线程安全与数据同步    97
4.1 数据同步 97
4.1.1 数据不一致问题的引入     97
4.1.2 数据不一致问题原因分析  99
4.2 初识 synchronized关键字    101
4.2.1 什么是synchronized   102
4.2.2
synchronized关键字的用法 103
4.3 深入synchronized关键字     105
4.3.1 线程堆栈分析     105
4.3.2 JVM指令分析     108
4.3.3 使用synchronized需要注意的问题   112
4.4 This Monitor和Class Monitor的详细介绍   114
4.4.1 this
monitor   114
4.4.2 class
monitor 117
4.5 程序死锁的原因以及如何诊断    120
4.5.1 程序死锁     120
4.5.2 程序死锁举例     121
4.5.3 死锁诊断     124
4.6 本章总结 126
第5章：线程间通信    127
5.1 同步阻塞与异步非阻塞 127
5.1.1 同步阻塞消息处理     127
5.1.2 异步非阻塞消息处理  128
5.2 单线程间通信 129
5.2.1 初识wait和notify      129
5.2.2 wait和notify方法详解       133
5.2.3 wait和notify注意事项       135
5.2.4 wait vs
sleep  137
5.3 多线程间通信 137
5.3.1 生产者消费者     137
5.3.2 线程休息室wait set    140
5.4 自定义显式锁BooleanLock   141
5.4.1
synchronized关键字的缺陷 142
5.4.2 显式锁BooleanLock   143
5.5 本章总结 153
第6章：ThreadGroup详细讲解  155
6.1 ThreadGroup与Thread   155
6.2 创建Thread Group 155
6.3 拷贝Thread数组和ThreadGroup数组 157
6.3.1 拷贝Thread数组 157
6.3.2 拷贝ThreadGroup数组      159
6.4 ThreadGroup操作   160
6.4.1
ThreadGroup的基本操作    161
6.4.2
ThreadGroup的interrupt     164
6.4.3
ThreadGroup的destroy       166
6.4.4 守护ThreadGroup       168
6.5 本章总结 169
第7章：Hook线程以及捕获线程执行异常      170
7.1 获取线程运行时异常    170
7.1.1
UncaughtExceptionHandler介绍 170
7.1.2
UncaughtExceptionHandler实例 171
7.1.3
UncaughtExceptionHandler源码分析 173
7.2 注入钩子线程（Hook）       175
7.2.1 Hook线程介绍    175
7.2.2 Hook线程实战    177
7.2.3 Hook线程应用场景以及注意事项    179
7.3 本章总结 179
第8章：线程池原理以及自定义线程池    180
8.1 线程池原理    180
8.2 线程池实现    181
8.2.1 线程池接口定义  182
8.2.2 线程池详细实现  188
8.3 线程池应用    198
8.4 本章总结 202
第二部分：Java ClassLoader       204
第9章 类的加载过程  205
9.1 类的加载过程介绍 205
9.2 类的主动使用和被动使用    206
9.3 类加载过程详解    209
9.3.1 类的加载阶段     210
9.3.2 类的连接阶段     212
9.3.3 类的初始化阶段  219
9.4 本章总结 221
第10章 JVM类加载器       224
10.1 JVM内置三大类加载器      224
10.1.1 根类加载器介绍       225
10.1.2 扩展类加载器介绍   226
10.1.3 系统类加载器介绍   227
10.2 自定义类加载器   227
10.2.1 自定义类加载器，问候世界   228
10.2.2 双亲委托机制详细介绍   233
10.2.3 破坏双亲委托机制   236
10.2.4 类加载器命名空间，运行时包，类的卸载等       239
10.3 本章总结      246
第11章 线程上下文类加载器    249
11.1 为什么需要线程上下文类加载器      249
11.2 数据库驱动的初始化源码分析   250
第三部分
深入理解volatile关键字    254
第12章 volatile关键字的介绍   255
12.1 初识volatile关键字     255
12.2 机器硬件CPU      257
12.3 Java 内存模型      262
第13章 深入volatile关键字      265
13.1 并发编程的三个重要特性   265
13.1.1 原子性       265
13.1.2 可见性       266
13.1.3 有序性       266
13.2 JMM如何保证三大特性      268
13.2.1 JMM与原子性   269
13.2.2 JMM与可见性   271
13.2.3 JMM与有序性   272
13.3 volatile关键字深入解析      273
13.3.1 volatile关键字的语义       274
13.3.2 volatile的原理和实现机制       277
13.3.3 volatile的使用场景   278
13.3.4 volatile
vs synchronized     280
第15章 7种单例设计模式的设计     282
14.1 饿汉式   282
14.2 懒汉式   283
14.3 懒汉式 同步方法 284
14.4
Double-Check 285
14.5
Volatile Double-Check  288
14.6 Holder方式   288
14.7枚举方式       289
14.8本章总结       291
第四部分
多线程设计架构模式  292
第15章 监控任务的生命周期    296
15.1 场景描述      296
15.2 当观察者模式遇到Thread   296
15.2.1 接口定义   296
15.2.2
ObservableThread实现      300
15.3 测试及技巧总结   303
15.3.1 测试运行   303
15.3.2 关键点总结       304
第16章 Single
Thread Execution设计模式       305
16.1 机场过安检   305
16.1.1 非线程安全       305
16.1.2 问题分析   308
16.1.3 线程安全   310
16.2 吃面问题      311
16.2.1 吃面引起的死锁       312
16.2.2 解决吃面引起的死锁问题       314
16.2.3 哲学家吃面       316
16.3 本章总结      317
第17章 读写锁分离设计模式    318
17.1 场景描述      318
17.2 读写分离程序设计      318
17.2.1 接口定义   318
17.2.2 程序实现   321
17.3 读写锁的使用      328
17.4 关于更多读写锁的话题      332
第18章 不可变对象设计模式    334
18.1 线程安全性   334
18.2 不可变对象的设计      334
18.2.1 非线程安全的累加器       335
18.2.2 方法同步增加线程安全性       338
18.2.3 不可变的累加器对象设计       339
18.3 技巧总结      341
第19章 Future设计模式    342
19.1 先给你一张凭据   342
19.2 Future设计模式实现    342
19.2.1 接口定义   343
19.2.2 程序实现   344
19.3 Future的使用以及技巧总结       347
19.4 增强FutureService使其支持回调      349
19.5 本章总结      351
第20章 Guarded
Suspension 设计模式     352
20.1 什么是Guarded Suspension设计模式       352
20.2 Guarded
Suspension示例     352
第21章 线程上下文设计模式    355
21.1 什么是上下文      355
21.2 线程上下文设计   356
21.3 ThreadLocal详解   358
21.3.1
ThreadLocal的使用场景及注意事项       358
21.3.2
ThreadLocal的方法详解及源码分析       359
21.3.3
ThreadLocal的内存泄漏问题分析   365
21.4 使用ThreadLocal设计线程上下文     370
第22章 Balking设计模式   373
22.1 什么是Balking设计    373
22.2 Balking模式之文档编辑      374
22.2.1 Document    374
22.2.2
AutoSaveThread  377
22.2.3
DocumentEditThread  378
22.3 本章总结      380
第23章 Latch设计模式      381
23.1 什么是Latch 381
23.2
CountDownLatch程序实现  382
23.2.1 无限等待的Latch     382
23.2.2 有超时设置的Latch  387
23.3 Latch设计模式总结     389
第24章
Thread-Per-Message设计模式      392
24.1 什么是Thread-Per-Message 392
24.2 每个任务一个线程      392
24.3 多用户的网络聊天      395
24.3.1 服务端程序       396
24.3.2 响应客户端连接的Handler     397
24.3.3 聊天程序测试   400
24.4 本章总结      400
第25章 Two Phase
Termination设计模式  401
25.1 什么是Two Phase Termination    401
25.2 Two Phase
Termination示例 402
25.2.1 线程停止的Two Phase Termination 402
25.2.2 进程关闭的Two Phase Termination 404
25.3 知识扩展      404
25.3.1 Strong
Reference（强引用）及LRUCache      405
25.3.2 Soft
Reference（软引用）及SoftLRUCache   410
25.3.3 Weak
Reference（弱引用）      413
25.3.4 Phantom
Reference（幻影引用）     415
25.4 本章总结      418
第26章
Worker-Thread设计模式      419
26.1 什么是Worker-Thread模式 419
26.2
Worker-Thread模式实现      419
26.2.1 产品及组装说明书   420
26.2.2 流水线传送带   421
26.2.3 流水线工人       423
26.3
Worker-Thread模式测试与总结  425
26.3.1 产品流水线测试       425
26.3.2
Worker-Thread vs Producer-Consumer     426
第27章 Active
Objects设计模式       428
27.1 接受异步消息的主动对象   428
27.2 标准Active Objects模式设计     428
27.2.1
OrderService接口设计      430
27.2.2
OrderServiceImpl 详解     431
27.2.3
OrderServiceProxy详解    432
27.2.4
MethodMessage   434
27.2.5
ActiveMessageQueue  437
27.2.6
OrderServiceFactory及测试     439
27.3 通用Active Objects框架设计     441
27.3.1
ActiveMessage详解    442
27.3.2
@ActiveMethod  445
27.3.3
ActiveServiceFactory详解 446
27.3.4
ActiveMessageQueue及其它     449
27.4 Active
Objects总结       451
第28章 Event Bus（消息总线）设计模式       452
28.1 Event Bus设计      452
28.1.1 Bus接口详解     453
28.1.2 同步EventBus详解  455
28.1.3 异步EventBus详解  458
28.1.4
Subscriber注册表Registry详解       459
28.1.5 Event广播Dispatcher详解       462
28.1.6其它类接口设计 466
28.1.7 Event Bus测试   468
28.2 Event Bus实战--监控目录变化   470
28.2.1
WatchService遇到EventBus     471
28.2.2
FileChangeEvent 473
28.2.3 监控目录变化   473
28.3 EventBus总结       475
第29章 Event
Driven(事件驱动) 设计模式     476
29.1 Event-Driven
Architecture基础    476
29.1.1 Events  476
29.1.2 Event
Handlers   477
29.1.3 Event
Loop  478
29.2 开发一个Event-Driven 框架     480
29.2.1 同步EDA框架设计  480
29.2.2 异步EDA框架设计  487
29.3
Event-Driven的使用    492
29.3.1 Chat
Event  492
29.3.2 Chat
Channel(Handler)      494
29.3.3 Chat User线程   495
29.4 本章总结      498
