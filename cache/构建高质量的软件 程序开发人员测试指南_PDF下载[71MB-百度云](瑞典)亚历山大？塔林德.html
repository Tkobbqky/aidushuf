构建高质量的软件/程序开发人员测试指南 PDF下载 (瑞典)亚历山大？塔林德 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711548008
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711548008
<p>书名:构建高质量的软件/程序开发人员测试指南</p><p>作者:(瑞典)亚历山大？塔林德</p><p>页数:219</p><p>定价:¥69.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2018-05-01</p><p>ISBN:9787115480088</p><p><h2>本书特色</h2></p>[<p>
本书分为19章，主要内容为开发人员测试，测试目标、方式和角色，测试术语，开发人员眼中的可测试性，契约式编程，可测试性的驱动者，单元测试，基于规格说明的测试，依赖关系，数据驱动和组合测试，准单元测试，测试替身，模拟框架，测试驱动开发——经典风格，测试驱动开发——Mockist风格，使用测试代码，超越单元测试，测试思路等开发人员和测试人员必知必会的知识。
如果你是一个希望所写的代码质量更高、缺陷更少的开发人员，那么这本书很适合你。本书介绍了如何用可测试性提升软件质量，在各种开发模式中，可测试性都是软件的主要质量属性之一。阅读本书，你可以成为更好的开发人员，学习到更多的软件测试知识，不必再苦于没有时间做测试、也无法从同事或团队那里获得相关的支持。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书分为19章，主要内容为开发人员测试，测试目标、方式和角色，测试术语，开发人员眼中的可测试性，契约式编程，可测试性的驱动者，单元测试，基于规格说明的测试，依赖关系，数据驱动和组合测试，准单元测试，测试替身，模拟框架，测试驱动开发——经典风格，测试驱动开发——Mockist风格，使用测试代码，超越单元测试，测试思路等开发人员和测试人员必知必会的知识。如果你是一个希望所写的代码质量更高、缺陷更少的开发人员，那么这本书很适合你。本书介绍了如何用可测试性提升软件质量，在各种开发模式中，可测试性都是软件的主要质量属性之一。阅读本书，你可以成为更好的开发人员，学习到更多的软件测试知识，不必再苦于没有时间做测试、也无法从同事或团队那里获得相关的支持。</p>]<p><h2>作者简介</h2></p>[<p>朱少民，国内软件测试界的领军人物和知名专家，三十多年来一直从事软件测试、质量管理和过程改进等工作，过去五年帮助了近百家企业提升其质量保证与测试能力，先后获得安徽省、原机械工业部、青岛市、合肥市等多项科技进步奖，出版了十多部著作，包括测试方面的畅销书《全程软件测试》、《软件测试方法和技术》、《完美测试》和译作《自动化测试最佳实践》等，经常在国内外会议上发表演讲，并在国内开设软件测试MOOC课程。之前曾任思科-网迅（中国）软件有限公司QA总监，目前是同济大学软件学院教授、中国科技大学软件学院教指委委员。
杨晓慧，前华为技术有限公司-软件公司测试专家，1999年进入华为公司，先后参与和主持过多项产品测试、测试流程改造、测试工程师职责定义等工作。工作覆盖测试策略、测试设计、测试评估和过程管理等软件测试工程的各个方面，在自动化、可靠性验证、可服务性验证、可测试性设计等领域上都有丰富的经验。2007年以后主管软件公司的测试技术架构设计、实现、应用，通过帮助产品持续积累和提升测试技术能力，实现研发的效率和质量提升。
欧阳辰，品友互动CTO。推动品友大数据智能战略，成为程序化广告的知名公司。加入品友之前，曾在微软、小米和甲骨文工作：曾任小米研发总监，负责广告和大数据平台，曾在微软工作十年，负责搜索和广告平台的核心大数据项目，持有数项国内外专利，著有《Druid实时大数据分析》。
曾乐天，博士，毕业于西安电子科技大学，现在工业和信息化部电子第五研究所（中国赛宝实验室）从事软件测评方面的研究工作。</p>]<p><h2>目录</h2></p>
    第 1章　开发者测试	1
1.1　开发者测试　1
1.2　开发人员测试活动　2
1.2.1　单元测试　2
1.2.2　集成测试　2
1.2.3　维护　2
1.2.4　持续集成　3
1.2.5　自动化测试　3
1.3　开发人员通常不做什么　4
1.4　定义“开发者测试”　5
1.5　开发人员测试和开发过程　5
1.6　小结　6
第　2章 测试目标、方式和角色　7
2.1　测试和检查　7
2.2　测试目标　7
2.2.1　批判式测试　8
2.2.2　支持式测试　8
2.3　测试方式　8
2.3.1　传统测试　9
2.3.2　敏捷测试　10
2.3.3　BDD、ATDD和实例化需求　11
2.4　质量保证和开发者测试　13
2.5　小结　14
第3章　测试术语　15
3.1　错误、缺陷、失效　15
3.2　白盒测试与黑盒测试　16
3.3　测试技术分类　16
3.3.1　测试级别　17
3.3.2　测试类型　19
3.3.3　让测试级别和测试类型
发挥作用　21
3.4　敏捷测试四象限　22
3.5　其他类型的测试　23
3.5.1　冒烟测试　23
3.5.2　端到端测试　24
3.5.3　特性测试　24
3.5.4　正面测试和负面测试　24
3.5.5　小型、中型和大型测试　24
3.6　小结　25
第4章　开发者眼中的可测试性　26
4.1　可测试的软件　26
4.2　可测试性的好处　27
4.2.1　功能可被验证　27
4.2.2　减少意外　28
4.2.3　它可以改变　28
4.2.4　为什么要注重可测试性　29
4.3　可测试性的定义　30
4.3.1　可观察性　31
4.3.2　可控制性　33
4.3.3　可部署性　34
4.3.4　可隔离性　35
4.3.5　小规模（smallness）　36
4.3.6　单一性　36
4.3.7　抽象级别　37
4.3.8　效率（efficiency）　38
4.3.9　复用　38
4.3.10　可测试性的提示　38
4.4　小结　39
第5章　契约式编程　40
5.1　契约形式化约束　41
5.2　实现契约式编程　42
5.3　强制契约　43
5.3.1　断言　43
5.3.2　支持契约的类库　44
5.3.3　单元测试　45
5.3.4　静态分析　45
5.4　小结　45
第6章　可测试性的驱动者　47
6.1　直接输入和输出　47
6.2　间接输入和输出　48
6.3　状态　49
6.4　时序耦合　50
6.5　数据类型和可测试性　50
6.6　域值比　54
6.7　小结　55
第7章　单元测试　56
7.1　为什么做单元测试？　56
7.2　什么是单元测试　57
7.3　单元测试框架的生命周期　58
7.3.1　测试方法　59
7.3.2　测试初始化器和清除　59
7.3.3　构造函数和析构函数　60
7.4　测试命名　60
7.4.1　测试框架的强制规定　60
7.4.2　行为驱动的开发方式　61
7.4.3　工作单元、测试状态、
所期望的行为　61
7.4.4　选择一个命名标准　61
7.5　测试结构化　62
7.6　断言方法　63
7.6.1　断言类型　63
7.6.2　每个测试有多少断言　64
7.6.3　断言冗长　65
7.6.4　断言等式　66
7.6.5　限制和匹配器　67
7.7　测试异常　70
7.8　行为驱动开发方式的框架　72
7.8.1　测试结构　72
7.8.2　命名测试　73
7.8.3　匹配器　74
7.9　小结　75
第8章　基于规格说明的测试　76
8.1　等价类划分　76
8.2　边界值分析　78
8.3　典型数据类型的边缘用例和其他
测试用例　79
8.3.1　数字　79
8.3.2　字符串　79
8.3.3　日期和时间　80
8.3.4　集合　80
8.4　状态转移测试　81
8.5　决策表　82
8.6　小结　83
第9章　依赖关系　84
9.1　对象间依赖关系　84
9.1.1　传入协作者　85
9.1.2　使用工厂方法　86
9.1.3　提供一个外部工厂或者
生成器　87
9.2　系统资源依赖关系　89
9.2.1　文件　89
9.2.2　提供你自己的抽象　89
9.2.3　测试由I/O操作处理过的
数据　90
9.2.4　系统时钟　91
9.2.5　其他系统资源依赖关系　92
9.3　层间依赖关系　92
9.4　跨层级依赖关系　94
9.5　小结　95
第　10章 数据驱动和组合测试　96
10.1　参数化测试　98
10.2　Theories　99
10.3　生成式测试　101
10.3.1　验证结果　102
10.4　组合测试　103
10.4.1　单模式故障　104
10.4.2　双模式故障　105
10.4.3　双模式故障和所有成对变量
之外　106
10.5　小结　106
第　11章 准单元测试　107
11.1　实例　107
11.1.1　使用内存数据库的测试　108
11.1.2　测试专用的邮件服务器　108
11.1.3　使用轻量级容器的测试　109
11.1.4　Web服务测试　110
11.2　影响　111
11.3　小结　112
第　12章 测试替身　113
12.1　桩对象　113
12.1.1　桩对象的灵活性　114
12.1.2　用桩对象来避免副作用　115
12.2　伪对象　116
12.3　模拟对象　117
12.3.1　验证间接输出　117
12.3.2　验证间接输入转换　121
12.4　探针　122
12.5　哑对象　123
12.6　验证状态还是行为　124
12.6.1　状态验证　124
12.6.2　行为验证　125
12.6.3　参数　125
12.7　小结　126
第　13章 模拟框架　127
13.1　创建测试替身　127
13.2　设置预期　128
13.3　验证交互行为　131
13.4　误用、滥用和其他陷阱　133
13.4.1　过度验证　133
13.4.2　模拟具体类　134
13.4.3　模拟有价值的类　135
13.4.4　Mock返回Mock　135
13.5　小结　135
第　14章 测试驱动开发——经典风格　137
14.1　测试驱动一个简单的搜索引擎　137
14.1.1　测试1：发现API　138
14.1.2　测试2：主逻辑路径（Happy Path）　139
14.1.3　测试3：多文件索引　140
14.1.4　测试4：更复杂的文件　141
14.1.5　测试5：在多文件中找到单词　141
14.1.6　测试6：消除重复的匹配（Matches）　142
14.1.7　测试7：引入排序　143
14.1.8　测试8：忽略大小写　145
14.1.9　测试9：处理标点符号　146
14.2　测试的顺序　147
14.3　红色到绿色状态条的策略　147
14.4　挑战　148
14.4.1　我们的代码无法被测试　149
14.4.2　我们的代码很特殊　150
14.4.3　测试驱动开发不是完整的测试　150
14.4.4　从零开始　150
14.5　测试*先还是*后　151
14.6　小结　151
第　15章 测试驱动开发——Mockist风格　153
15.1　一种不同的方法　153
15.1.1　测试驱动用户注册　154
15.1.2　增加更多测试　158
15.2　双环TDD　159
15.2.1　另一个反馈环　159
15.2.2　关闭周期　160
15.3　小结　160
第　16章 复制　161
16.1　复制的坏处　161
16.2　利用复制的好处　162
16.3　机械复制　163
16.3.1　拷贝、粘贴　163
16.3.2　块拷贝、粘贴　163
16.3.3　构造函数拷贝、粘贴　164
16.3.4　方法复制　165
16.4　知识复制　166
16.4.1　不同方法中的类似功能　167
16.4.2　功能相似的类　167
16.4.3　竞争性实现　168
16.4.4　竞争性领域模型　168
16.5　小结　169
第　17章 使用测试代码　170
17.1　测试代码中的注释　170
17.2　删除测试用例　173
17.2.1　需要被删除的主要候选者　173
17.2.2　需要被删除的可能候选者　174
17.2.3　删除测试用例的重要性　174
17.3　小结　175
第　18章 超越单元测试　176
18.1　单元测试以外的测试　176
18.1.1　封装在事务内的测试　176
18.1.2　需要使用服务或组件的测试　178
18.1.3　需要与其他系统交互的测试　179
18.1.4　通过UI运行的测试　181
18.1.5　需要调用一个系统的测试　183
18.1.6　更多内容　184
18.2　单元测试不具备的特征　185
18.2.1　复杂性　186
18.2.2　稳定性　186

18.2.3　缺陷定位　187
18.2.4　性能　187
18.2.5　环境依赖性　188
18.2.6　目标受众　188
18.3　实践指南　189
18.3.1　测试的独立性　189
18.3.2　配置　189
18.3.3　验证　191
18.3.4　利用测试替身　191
18.3.5　决定开发者测试策略　192
18.4　小结　193
第　19章 测试思路与启发式　194
19.1　高层注意事项　194
19.1.1　测试有效性　194
19.1.2　测试配方　194
19.1.3　抽象级别及其细节　195
19.1.4　原型　195
19.1.5　可信来源（结果判断依据）　196
19.2　低层注意事项　196
19.2.1　0-1-n　196
19.2.2　空值（null）　196
19.2.3　范围　196
19.2.4　集合　196
19.2.5　异常和错误　197
19.2.6　数字　197
19.2.7　字符串　197
19.2.8　日期　197
19.3　小结　198
附录A　工具和库　199
附录B　源代码　201
词汇表　209
后记：忘却测试是为了更好的开发　216


