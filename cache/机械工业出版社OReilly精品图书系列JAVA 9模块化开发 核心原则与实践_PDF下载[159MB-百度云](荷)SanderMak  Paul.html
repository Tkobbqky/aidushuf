机械工业出版社OReilly精品图书系列JAVA 9模块化开发:核心原则与实践 PDF下载 (荷)SanderMak//Paul 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711160129
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711160129
<p>书名:机械工业出版社OReilly精品图书系列JAVA 9模块化开发:核心原则与实践</p><p>作者:(荷)Sander Mak//Paul </p><p>页数:234</p><p>定价:¥69.0</p><p>出版社:机械工业出版社</p><p>出版日期:2018-06-01</p><p>ISBN:9787111601296</p><p><h2>本书特色</h2></p>[<p>
Java9向Java平台引入了模块系统，这是一个非常重要的飞跃，标志着模块化Java软件开发的新纪元。当需要创建灵活且易于维护的代码时，模块化是一个关键的架构设计原则。本书给出了Java模块系统的明确概述，并演示了如何通过创建模块化应用程序来帮助管理以及降低复杂性。作者引导我们了解了模块系统中的相关概念以及工具，介绍了将现有代码迁移到模块中的模式以及以模块方式构建新应用程序的方法。
                                        </p>]<p><h2>内容简介</h2></p>[<p>Java9向Java平台引入了模块系统，这是一个很好重要的飞跃，标志着模块化Java软件开发的新纪元。当需要创建灵活且易于维护的代码时，模块化是一个关键的架构设计原则。本书给出了Java模块系统的明确概述，并演示了如何通过创建模块化应用程序来帮助管理以及降低复杂性。作者引导我们了解了模块系统中的相关概念以及工具，介绍了将现有代码迁移到模块中的模式以及以模块方式构建新应用程序的方法。</p>]<p><h2>作者简介</h2></p>[<p>桑德·马克（Sander Mak） 荷兰 Luminis公司的一名研究员，开发了许多主要用于JVM上的模块化以及可扩展软件，但也会在需要的地方使用TypeScript。他经常在各种会议上发言，并热衷于通过博客（http://branchandbound.net）和作为Pluralsight平台的讲师分享知识。<br/><br/>保罗·巴克（Paul Bakker） Netflix公司的一名高级软件工程师，在其Edge Developer Experience团队主要从事工具的开发，以提高公司内部开发人员的工作效率。曾与他人合作编著了《Modular Cloud Apps with OSGi》（由O''Reilly出版公司出版）一书。Paul经常在与模块化、容器技术相关主题的会议上发言。<br/><br/></p>]<p><h2>目录</h2></p>
    目录前言1**部分 Java模块系统介绍第1章 模块化概述81.1 什么是模块化91.2 在Java 9之前101.2.1 将JAR作为模块？111.2.2 类路径地狱131.3 Java 9模块14第2章 模块和模块化JDK182.1 模块化JDK192.2 模块描述符222.3 可读性232.4 可访问性242.5 隐式可读性252.6 限制导出292.7 模块解析和模块路径292.8 在不使用模块的情况下使用模块化JDK31第3章 使用模块333.1 **个模块333.1.1 剖析模块333.1.2 命名模块353.1.3 编译363.1.4 打包373.1.5 运行模块373.1.6 模块路径393.1.7 链接模块403.2 任何模块都不是一座孤岛413.2.1 EasyText示例介绍413.2.2 两个模块433.3 使用平台模块463.3.1 找到正确的平台模块463.3.2 创建GUI模块473.4 封装的限制51第4章 服务544.1 工厂模式544.2 用于实现隐藏的服务574.2.1 提供服务574.2.2 消费服务594.2.3 服务生命周期614.2.4 服务提供者方法624.3 工厂模式回顾644.4 默认服务实现654.5 服务实现的选择664.6 具有服务绑定的模块解析684.7 服务和链接70第5章 模块化模式735.1 确定模块边界745.2 精益化模块765.3 API模块765.3.1 API模块中应该包含什么775.3.2 隐式可读性785.3.3 带有默认实现的API模块815.4 聚合器模块825.4.1 在模块上构建一个外观835.4.2 安全拆分模块845.5 避免循环依赖865.5.1 拆分包865.5.2 打破循环875.6 可选的依赖关系905.6.1 编译时依赖关系915.6.2 使用服务实现可选依赖关系955.7 版本化模块965.8 资源封装995.8.1 从模块加载资源1005.8.2 跨模块加载资源1015.8.3 使用ResourceBundle类102第6章 高级模块化模式1046.1 重温强封装性1046.1.1 深度反射1056.1.2 开放式模块和包1066.1.3 依赖注入1096.2 对模块的反射1116.2.1 内省1126.2.2 修改模块1136.2.3 注释1146.3 容器应用程序模式1156.3.1 层和配置1166.3.2 层中的类加载1196.3.3 插件体系结构1226.3.4 容器体系结构1276.3.5 解析容器中的平台模块132第二部分 迁移第7章 没有模块的迁移1347.1 类路径已经“死”了？1357.2 库、强封装和JDK 9类路径1357.3 编译和封装的API1387.4 删除的类型1417.5 使用JAXB和其他Java EE API1427.6 jdk.unsupported模块1457.7 其他更改146第8章 迁移到模块1488.1 迁移策略1488.2 一个简单示例1498.3 混合类路径和模块路径1508.4 自动模块1528.5 开放式包1558.6 开放式模块1578.7 破坏封装的VM参数1588.8 自动模块和类路径1588.9 使用jdeps1618.10 动态加载代码1648.11 拆分包166第9章 迁移案例研究：Spring和Hibernate1679.1 熟悉应用程序1679.2 使用Java 9在类路径上运行1729.3 设置模块1739.4 使用自动模块1749.5 Java平台依赖项和自动模块1769.6 开放用于反射的包1769.7 解决非法访问问题1779.8 重构到多个模块178第10章 库迁移18010.1 模块化之前18110.2 选择库模块名称18110.3 创建模块描述符18410.4 使用模块描述符更新库18610.5 针对较旧的Java版本18710.6 库模块依赖关系18810.6.1 内部依赖关系18810.6.2 外部依赖关系19110.7 针对多个Java版本19210.7.1 多版本JAR19210.7.2 模块化多版本JAR195第三部分 模块化开发工具第11章 构建工具和IDE19811.1 Apache Maven19811.1.1 多模块项目20011.1.2 使用Apache Maven创建EasyText示例20011.1.3 使用Apache Maven运行模块化的应用程序20411.2 Gradle20511.3 IDE205第12章 测试模块20712.1 黑盒测试20812.2 使用JUnit进行黑盒测试21012.3 白盒测试21212.4 测试工具216第13章 使用自定义运行时映像进行缩减21713.1 静态链接和动态链接21813.2 使用jlink21913.3 查找正确的服务提供者模块22313.4 链接期间的模块解析22313.5 基于类路径应用程序的jlink22413.6 压缩大小22513.7 提升性能22713.8 跨目标运行时映像228第14章 模块化的未来22914.1 OSGi23014.2 Java EE23214.3 微服务23214.4 下一步233
