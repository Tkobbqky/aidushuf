操作系统-精髓与设计原理-(第八版) PDF下载 威廉.斯托林斯 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712130950
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712130950
<p>书名:操作系统-精髓与设计原理-(第八版)</p><p>作者:威廉.斯托林斯</p><p>页数:492</p><p>定价:¥79.8</p><p>出版社:电子工业出版社</p><p>出版日期:2017-03-01</p><p>ISBN:9787121309502</p><p><h2>本书特色</h2></p>[<p>
本书既是关于操作系统概念、结构和机制的教材，目的是尽可能清楚和全面地展示现代操作系统的本质和特点；也是讲解操作系统的经典教材，不仅系统地讲述了操作系统的基本概念、原理和方法，而且以当代*流行的操作系统Windows 8、UNIX、Android、Linux为例，展现了当代操作系统的本质和特点。全书共分背景知识、进程、内存、调度、输入/输出和文件、嵌入式系统六部分，内容包括计算机系统概述、操作系统概述、进程描述和控制、线程、并发性：互斥和同步、并发：死锁和饥饿、内存管理、虚拟内存、单处理器调度、多处理器和实时调度、I/O管理和磁盘调度、文件管理、嵌入式操作系统、虚拟机、计算机安全技术、分布式处理、客户/服务器和集群等。此外，本书配套网站提供了及时、生动的材料。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书的目的是使读者熟悉现代操作系统的设计原理和实现问题，因此单纯讲述概念和理论远远不够。为说明这些概念，同时将它们与真实世界中不得不做出的设计选择相关联，本书选择了4个操作系统作为实例：<br/>◆ Windows 8：用于个人计算机、工作站和服务器的多任务操作系统。它融入了很多操作系统发展的*技术。此外，Windows是*早采用面向对象原理进行设计的重要商业操作系统之一。本书涵盖了Windows*版本所采用的技术，包括Windows 8。<br/>◆ Android：Android是为嵌入式设备特别是手机量身定做的，主要是为了满足嵌入式环境的独特需求。本书介绍了Android的内核信息。<br/>◆ UNIX：*初是为小型计算机设计的多用户操作系统，但后来广泛用于从微机到超级计算机的各种机器中。本书采用若干版本的UNIX作为实例。FreeBSD融合了很多的现代特征，是一个广泛应用的操作系统；Solaris是一个广泛应用的商业版UNIX系统。<br/>◆ Linux：一个非常普及且源代码开放的UNIX版本。<br/>选择这些操作系统的原因是它们之间存在相关性，同时它们也具有代表性。关于这些实例操作系统的讨论贯穿全书，而非集中于某一章或附录部分。因此在讨论并发性时，会描述每个实例操作系统的并发机制，并探讨各种设计选择的动机。采用真实的例子可加深读者对相关章节中设计概念的理解。为方便起见，读者也可在在线文档中查阅所有实例操作系统的资料。 </p>]<p><h2>作者简介</h2></p>[<p>陈向群，北京大学信息科学技术学院计算机科学技术系教授，博士生导师，主要研究领域为软件需求工程、知识工程、基于知识的软件工程、面向服务的计算。
William Stallings：美国圣母大学电子工程学士，麻省理工学院计算机科学博士，《密码术》期刊编委。美国多家高科技公司执行总监，政府机构、计算机软/硬件供应商顾问；曾为各种计算机和操作系统设计并实现TCP/IP和OSI协议套件；创建并维护了计算机科学专业学生资源网站ComputerScienceStudent.com。出版图书17种，内容涉及计算机安全、计算机网络和计算机系统结构等；在《IEEE进展》《ACM计算评论》和《密码术》等期刊上发表文章多篇；先后12次获美国年度*计算机科学教科书奖和学术作者协会奖。</p>]<p><h2>目录</h2></p>
    第0章  读者与教师指南	1　　0.1  本书概述	1　　0.2  实例系统	1　　0.3  读者和教师的路线图	2　　0.4  互联网和网站资源	3**部分  背景知识第1章  计算机系统概述	6　　1.1  基本构成	6　　1.2  微处理器的发展	7　　1.3  指令的执行	8　　1.4  中断	101.4.1  中断和指令周期	111.4.2  中断处理	121.4.3  多个中断	14　　1.5  存储器的层次结构	15　　1.6  高速缓存	171.6.1  动机	181.6.2  高速缓存原理	181.6.3  高速缓存设计	19　　1.7  直接内存存取	20　　1.8  多处理器和多核计算机组织结构	21     1.8.1  对称多处理器	21     1.8.2  多核计算机	23　　1.9  推荐读物	23　　1.10 关键术语、复习题和习题	24     1.10.1  关键术语	24     1.10.2  复习题	24     1.10.3  习题	24　　附录1A  两级存储器的性能特征	26第2章  操作系统概述	31　　2.1  操作系统的目标和功能	312.1.1  作为用户/计算机接口的操作系统	31     2.1.2  作为资源管理器的操作系统	32     2.1.3  操作系统的易扩展性	33　　2.2  操作系统的发展史	34     2.2.1  串行处理	34     2.2.2  简单批处理系统	34     2.2.3  多道批处理系统	36     2.2.4  分时系统	38　　2.3  主要成就	402.3.1  进程	402.3.2  内存管理	422.3.3  信息保护和安全	432.3.4  调度和资源管理	44　　2.4  现代操作系统的特征	45　　2.5  容错性	472.5.1  基本概念	472.5.2  错误	482.5.3  操作系统机制	482.6  多处理器和多核操作系统设计考虑因素	492.6.1  对称多处理器操作系统设计考虑因素	49     2.6.2  多核操作系统设计考虑因素	49　　2.7  微软Windows系统简介	51     2.7.1  背景	51     2.7.2  体系结构	51     2.7.3  客户-服务器模型	53     2.7.4  线程和SMP	54     2.7.5  Windows对象	54　　2.8  传统的UNIX系统	55     2.8.1  历史	55     2.8.2  描述	56　　2.9  现代UNIX系统	57     2.9.1  System V Release 4（SVR4）	58     2.9.2  BSD	58     2.9.3  Solaris 10	58　　2.10 Linux操作系统	582.10.1  历史	582.10.2  模块结构	592.10.3  内核组件	60　　2.11 Android	622.11.1  Android软件体系结构	632.11.2  Android系统体系结构	642.11.3  活动	652.11.4  电源管理	65　　2.12 推荐读物和动画	66　　2.13 关键术语、复习题和习题	672.13.1  关键术语	672.13.2  复习题	672.13.3  习题	67第二部分  进程第3章  进程描述和控制	70　　3.1  什么是进程	703.1.1  背景	703.1.2  进程和进程控制块	71　　3.2  进程状态	723.2.1  两状态进程模型	733.2.2  进程的创建和终止	743.2.3  五状态模型	753.2.4  被挂起的进程	78　　3.3  进程描述	813.3.1  操作系统的控制结构	823.3.2  进程控制结构	82　　3.4  进程控制	863.4.1  执行模式	863.4.2  进程创建	873.4.3  进程切换	88　　3.5  操作系统的执行	903.5.1  无进程内核	903.5.2  在用户进程内运行	903.5.3  基于进程的操作系统	91　　3.6  UNIX SVR4进程管理	913.6.1  进程状态	923.6.2  进程描述	933.6.3  进程控制	94　　3.7  小结	95　　3.8  推荐读物和动画	95　　3.9  关键术语、复习题和习题	953.9.1  关键术语	953.9.2  复习题	963.9.3  习题	96第4章  线程	99　　4.1  进程和线程	994.1.1  多线程	994.1.2  线程的功能	102　　4.2  线程分类	1034.2.1  用户级和内核级线程	1034.2.2  其他方案	106　　4.3  多核和多线程	1074.3.1  多核系统上的软件性能	1074.3.2  应用示例：Valve游戏软件	109　　4.4  Windows 8的进程和线程管理	1104.4.1  Windows 8中的变化	1114.4.2  Windows进程	1114.4.3  进程对象和线程对象	1124.4.4  多线程	1134.4.5  线程状态	1134.4.6  对操作系统子系统的支持	114　　4.5  Solaris的线程和SMP管理	1144.5.1  多线程体系结构	1144.5.2  动机	1154.5.3  进程结构	1154.5.4  线程的执行	1164.5.5  把中断当作线程	117　　4.6  Linux的进程和线程管理	1184.6.1  Linux任务	1184.6.2  Linux线程	1194.6.3  Linux命名空间	120　　4.7  Android的进程和线程管理	1214.7.1  安卓应用	1214.7.2  活动	1214.7.3  进程和线程	122　　4.8  Mac OS X的GCD技术	123　　4.9  小结	124　　4.10 推荐读物	125　　4.11 关键术语、复习题和习题	1254.11.1  关键术语	1254.11.2  复习题	1254.11.3  习题	125第5章  并发性：互斥和同步	129　　5.1  并发的原理	1305.1.1  一个简单的例子	1305.1.2  竞争条件	1325.1.3  操作系统关注的问题	1325.1.4  进程的交互	1335.1.5  互斥的要求	135　　5.2  互斥：硬件的支持	1365.2.1  中断禁用	1365.2.2  专用机器指令	136　　5.3  信号量	1385.3.1  互斥	1415.3.2  生产者/消费者问题	1425.3.3  信号量的实现	146　　5.4  管程	1475.4.1  使用信号的管程	1475.4.2  使用通知和广播的管程	149　　5.5  消息传递	1515.5.1  同步	1515.5.2  寻址	1525.5.3  消息格式	1535.5.4  排队原则	1545.5.5  互斥	154　　5.6  读者/写者问题	1555.6.1  读者优先	1565.6.2  写者优先	156　　5.7  小结	158　　5.8  推荐读物和动画	159　　5.9  关键术语、复习题和习题	1605.9.1  关键术语	1605.9.2  复习题	1605.9.3  习题	160第6章  并发：死锁和饥饿	170　　6.1  死锁原理	1706.1.1  可重用资源	1736.1.2  可消耗资源	1746.1.3  资源分配图	1746.1.4  死锁的条件	175　　6.2  死锁预防	1766.2.1  互斥	1766.2.2  占有且等待	1766.2.3  不可抢占	1766.2.4  循环等待	177　　6.3  死锁避免	1776.3.1  进程启动拒绝	1776.3.2  资源分配拒绝	178　　6.4  死锁检测	1816.4.1  死锁检测算法	1816.4.2  恢复	182　　6.5  一种综合的死锁策略	182　　6.6  哲学家就餐问题	1836.6.1  基于信号量的解决方案	1836.6.2  基于管程的解决方案	184　　6.7  UNIX并发机制	1856.7.1  管道	1866.7.2  消息	1866.7.3  共享内存	1866.7.4  信号量	1866.7.5  信号	187　　6.8  Linux内核并发机制	1876.8.1  原子操作	1886.8.2  自旋锁	1896.8.3  信号量	1906.8.4  屏障	191　　6.9  Solaris线程同步原语	1926.9.1  互斥锁	1936.9.2  信号量	1936.9.3  多读者/单写者锁	1936.9.4  条件变量	193　　6.10 Windows 7的并发机制	1946.10.1  等待函数	1946.10.2  分派器对象	1946.10.3  临界区	1956.10.4  轻量级读写锁和条件变量	1956.10.5  锁无关同步机制	196　　6.11 Android进程间通信	196　　6.12 小结	197　　6.13 推荐读物和动画	197　　6.14 关键术语、复习题和习题	1986.14.1  关键术语	1986.14.2  复习题	1986.14.3  习题	198　　　　　　　　　　　　第三部分  内存　　第7章  内存管理	204　　7.1  内存管理的需求	2047.1.1  重定位	2047.1.2  保护	2057.1.3  共享	2057.1.4  逻辑组织	2057.1.5  物理组织	206　　7.2  内存分区	2067.2.1  固定分区	2077.2.2  动态分区	2087.2.3  伙伴系统	2107.2.4  重定位	212　　7.3  分页	212　　7.4  分段	215　　7.5  小结	216　　7.6  推荐读物和动画	216　　7.7  关键术语、复习题和习题	2167.7.1  关键术语	2167.7.2  复习题	2177.7.3  习题	217　　附录7A  加载和链接	219第8章  虚拟内存	223　　8.1  硬件和控制结构	2238.1.1  局部性和虚拟内存	2248.1.2  分页	2258.1.3  分段	2328.1.4  段页式	2328.1.5  保护和共享	233　　8.2  操作系统软件	2348.2.1  读取策略	2358.2.2  放置策略	2358.2.3  置换策略	2358.2.4  驻留集管理	2398.2.5  清除策略	2438.2.6  加载控制	244　　8.3  UNIX和Solaris内存管理	2458.3.1  分页系统	2458.3.2  内核内存分配器	247　　8.4  Linux内存管理	2498.4.1  虚拟内存	2498.4.2  内核内存分配	250　　8.5  Windows内存管理	2518.5.1  Windows虚拟地址映射	2518.5.2  Windows分页	2518.5.3  Windows 8交换	252　　8.6  Android内存管理	252　　8.7  小结	252　　8.8  推荐读物和动画	253　　8.9  关键术语、复习题和习题	2538.9.1  关键术语	2538.9.2  复习题	2548.9.3  习题	254第四部分  调度第9章  单处理器调度	258　　9.1  处理器调度的类型	2589.1.1  长程调度	2599.1.2  中程调度	2609.1.3  短程调度	260　　9.2  调度算法	2609.2.1  短程调度规则	2609.2.2  优先级的使用	2619.2.3  选择调度策略	2629.2.4  性能比较	2689.2.5  公平共享调度	272　　9.3  传统的UNIX调度	273　　9.4  小结	274　　9.5  推荐读物9
