易学C++-(第2版) PDF下载 潘嘉杰 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711544779
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711544779
<p>书名:易学C++-(第2版)</p><p>作者:潘嘉杰</p><p>页数:330</p><p>定价:¥59.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2017-05-01</p><p>ISBN:9787115447791</p><p><h2>本书特色</h2></p>[<p>
本书是为C  程序设计学习者量身订做的辅导书。
全书分为3篇。前篇介绍了面向过程的程序设计，主要有基本语句、语法基础、函数机制和数据类型等内容。中篇介绍了一些实用编程技巧，内容包括阅读代码、调试程序、异常处理和简单的编程思想。后篇介绍了面向对象的程序设计，主要有类和对象、对象生灭、友元、继承、标准模板库（STL）等内容。书中常以形象的比喻来解释程序设计中的概念，通俗易懂，令读者印象深刻，能更快地进入C  程序设计的大门。
本书的内容涵盖了绝大部分常用的C  知识，可以作为大学计算机专业或非计算机专业的程序设计入门教材，也可供计算机爱好者自学使用。
                                        </p>]<p><h2>内容简介</h2></p>[<p>形象的比喻，生动的讲解，重新诠释了学习语言的方法
★实用的示例，完整的代码，为学习者量身打造的案例
★易学、易懂、易于实践的知识结构，降低学习C   的门槛
一、书中的语言通俗易懂，常以形象的比喻和插图来解释C  的语法现象和各种概念，便于读者理解，使他们印象深刻。 
二、书中介绍大量实用技巧也是一项特色，特别是中篇系统地介绍程序的阅读、调试和编程思想，是市面上同类书籍少有的。 
三、从初学者的角度讲解C  ，降低了C  的学习门槛，是一本编程基础零起点的好教程。通过在网站上试读，已经得到广大C  编程爱好者的强烈响应和支持. 
易学C  在各大编程论坛反响强烈，具体情况如下：（有些是读者主动帮忙宣传） 
http://www.programfan.com/club/post-128283-1.html 
http://www.programfan.com/club/post-128840-1.html 
http://download.csdn.net/source/227661 
http://bbs.bc-cn.net/dispbbs.asp?boardID=56&amp;ID=37649&amp;page=1 
http://www.shubulo.com/viewthread.php?tid=32915 
上海的知名媒体《新闻晚报》也报道过《易学C  》： 
http://www.jfdaily.com/gb/jfxww/xinwen/node1222/node11824/userobject1ai1525250.html </p>]<p><h2>作者简介</h2></p>[<p>2008年毕业于上海大学计算机工程与科学学院。从事计算机信息系统开发工作8年多，目前在某英资仪器公司任项目经理、软件工程师。2005年起编写《易学C  》一书。</p>]<p><h2>目录</h2></p>
    前篇　过程化的程序设计
第1章　C  从这里开始	1
1.1　软件与程序	1
1.2　程序设计要做什么	2
1.3　选好一种语言	3
1.4　C  能够做些什么	3
1.5　C语言、C  语言和Visual C  	4
1.6　学习程序设计总体建议	5
1.7　C  学习的常见问题	6
1.8　缩略语和术语表	8
1.9　方法指导	8
1.10　习题	8
第2章　Hello，World！	10
2.1　Visual Studio 2012的安装和启动	10
2.2　如何创建一个程序	11
2.3　输出与输入	17
2.4　Visual C   6.0的使用	19
2.5　小巧的Dev-C  	22
2.5.1　Dev-C  的安装	22
2.5.2　Dev-C  的配置	23
2.5.3　Dev-C  的使用	24
2.6　缩略语和术语表	26
2.7　方法指导	26
2.8　习题	26
第3章　各种各样的箱子—变量	28
3.1　会变的箱子	28
3.1.1　数据类型	28
3.1.2　变量名	29
3.1.3　变量的初始化	30
3.2　常用的基本数据类型	30
3.2.1　整型（Integer）	30
3.2.2　浮点型（Floating Point）	32
3.2.3　字符型（Character）	32
3.2.4　布尔型（Boolean）	33
3.3　不会变的箱子	33
3.4　算术表达式	34
3.4.1　操作符和表达式	34
3.4.2　算术操作符	35
3.5　箱子的转换	36
3.5.1　隐式转换	36
3.5.2　显式转换	36
3.6　缩略语和术语表	37
3.7　方法指导	38
3.8　习题	38
第4章　要走哪条路—分支结构	40
4.1　如果……	40
4.1.1　条件—关系操作符	41
4.1.2　条件—逻辑操作符	44
4.1.3　&&和||的妙用	47
4.2　否则……	47
4.2.1　如果与否则	48
4.2.2　如果里的如果…… 	50
4.2.3　找朋友	51
4.3　爱判断的问号	52
4.4　切换的开关	52
4.4.1　多路开关—switch	53
4.4.2　巧用switch	55
4.5　缩略语和术语表	56
4.6　方法指导	56
4.7  习题	56
第5章　有个圈儿的程序—循环结构	61
5.1　程序赛车	61
5.1.1　循环语句for	61
5.1.2　加加和减减	63
5.1.3　巧用for	64
5.2　退出比赛和进维修站	65
5.2.1　退出比赛—break	65
5.2.2　进维修站—continue	66
5.3　圈圈里的圈圈	67
5.3.1　循环的嵌套	67
5.3.2　怎么让输出的东西更好看	68
5.4　当……	70
5.4.1　当型循环	70
5.4.2　导火索—do	71
5.5　缩略语和术语表	73
5.6　方法指导	73
5.7　习题	73
第6章　好用的工具—函数	78
6.1　简单的工具	78
6.1.1　工具的说明书	78
6.1.2　如何使用系统造好的工具	80
6.2　打造自己的工具	81
6.2.1　函数的声明	82
6.2.2　函数的定义	82
6.2.3　函数是如何运行的	83
6.2.4　返回语句—return	83
6.2.5　关于主函数	83
6.2.6　同名同姓	84
6.2.7　函数存在的意义	85
6.3　多功能开瓶器—函数重载	86
6.4　自动的“工具”	88
6.4.1　默认参数	88
6.4.2　定义默认参数的顺序	89
6.4.3　默认参数和重载函数的混淆	89
6.5　给变量和参数起个“绰号”—引用	90
6.5.1　引用的声明	90
6.5.2　用引用传递参数	91
6.6*　函数里的函数—递归	92
6.7　缩略语和术语表	93
6.8　方法指导	93
6.9　习题	94
第7章　好大的“仓库”—数组	98
7.1　让计算机处理更多数据—使用数组	98
7.1.1　数组的声明	98
7.1.2　数组的操作	99
7.1.3　数组的初始化	100
7.1.4　省略数组大小	100
7.2　仓库是怎样造成的	101
7.2.1　内存和地址	101
7.2.2　数组在内存中的存储情况	101
7.2.3　字符的存储情况	102
7.2.4　字符数组在内存中的存储
情况	103
7.3　向函数传递数组	104
7.4　二维数组	106
7.4.1　线与面	106
7.4.2　二维数组的声明和初始化	107
7.4.3　省略**维的大小	108
7.4.4　二维数组在内存中的存储
情况	108
7.4.5　向函数传递二维数组	108
7.4.6　二维数组转化成一维数组	109
7.5　缩略语和术语表	110
7.6　方法指导	110
7.7　习题	110
第8章　内存里的快捷方式—指针	114
8.1　什么是指针	114
8.2　指针变量的声明和使用	114
8.2.1　指针的类型	115
8.2.2　指针变量的声明	115
8.2.3　获取地址和指针变量初始化	115
8.2.4　特殊的值—NULL	116
8.2.5　指针的使用—间接引用	116
8.3　指针的操作	117
8.3.1　指针的加减运算	117
8.3.2　指针的关系运算	118
8.4　指针与保护	118
8.4.1　对内存只读的指针	118
8.4.2　指针型常量	119
8.5　指针与数组	119
8.5.1　数组名的实质	120
8.5.2　指针数组	120
8.6　指针与函数	121
8.6.1　指针作为参数	121
8.6.2　指针作为返回值	122
8.7　更灵活的存储	123
8.7.1　如何获得堆内存空间	123
8.7.2　有借有还，再借不难	123
8.8　缩略语和术语表	124
8.9　方法指导	125
8.10　习题	125
第9章　自己设计的箱子—枚举和结构	129
9.1　我的类型我做主—枚举类型	129
9.2　设计一个收纳箱—结构类型	131
9.3　结构与函数	134
9.3.1　结构作为参数	134
9.3.2　结构作为返回值	135
9.4　结构数组与结构指针	136
9.4.1　结构数组	136
9.4.2　结构指针	136
9.5　自行车的链条—链表	137
9.6　链表的实现	139
9.6.1　链表的创建和遍历	139
9.6.2　链表的查询	141
9.6.3　插入结点	142
9.6.4　删除结点	144
9.6.5　清除链表	145
9.7　缩略语和术语表	146
9.8　方法指导	146
9.9　习题	147
中篇　实战程序设计
第10章　如何阅读程序代码	151
10.1　整体把握法	151
10.1.1　阅读代码的顺序	151
10.1.2　整体把握语意	152
10.2　经验法	153
10.3　模拟法	154
10.4　方法指导	155
10.5　习题	156
第11章　如何调试程序代码	159
11.1　再谈变量	159
11.1.1　标识符	159
11.1.2　全局变量和局部变量	159
11.1.3　静态局部变量	161
11.1.4　变量的作用域	163
11.1.5　变量的可见性	164
11.2　头文件的奥秘	165
11.2.1　如何创建一个头文件	165
11.2.2　头文件里有什么	166
11.2.3　头文件和源文件	168
11.2.4　细说#include	168
11.2.5　尖括号和双引号的区别	168
11.2.6　外部依赖项	169
11.3　更快更好地完成程序调试	170
11.3.1　如何检查语法错误	170
11.3.2　常见语法错误及解决方法	173
11.4　*麻烦的问题	174
11.4.1　见识运行时错误	174
11.4.2　查找错误点	175
11.5　在VS2012里调试程序	178
11.5.1　如何设置和移除断点	178
11.5.2　走起	178
11.5.3　调试工具栏	179
11.5.4　监视和自动窗口	180
11.5.5　如何通过调试找到错误	181
11.6　缩略语和术语表	181
11.7　方法指导	181
11.8　习题	182
第12章　如何编写程序代码	185
12.1　程序设计的基本步骤	185
12.2　三类问题	186
12.2.1　算	186
12.2.2　找	187
12.2.3　实现功能	188
12.3　函数的递归	190
12.3.1　什么是栈	190
12.3.2　函数的调用机制	190
12.3.3　小试牛刀—用递归模拟栈	192
12.3.4*　递归的精髓	193
12.4　缩略语和术语表	195
12.5　方法指导	195
12.6　习题	196
第13章　异常的处理	198
13.1　亡羊也要补牢	198
13.2　处理异常	199
13.2.1　尽力尝试	200
13.2.2　抓住异常	200
13.3　抛出异常	202
13.4　缩略语和术语表	203
13.5　方法指导	203
13.6　习题	204
后篇　面向对象的程序设计
第14章　初识对象	205
14.1　对象就是物体	205
14.2　一个字符串也是对象	205
14.2.1　奇妙的点	206
14.2.2　对字符串的操作	206
14.3　面向对象特点一：封装性	208
14.4　缩略语和术语表	208
14.5　方法指导	208
14.6　习题	209
第15章　再识对象	210
15.1　类是一种数据类型	210
15.1.1　类与结构	210
15.1.2　类的声明与定义	211
15.2　公有和私有	211
15.3　成员函数	212
15.3.1　成员函数的声明	212
15.3.2　常成员函数	212
15.3.3　成员函数的重载	213
15.3.4　成员函数的定义	213
15.4　如何方便地查看类	215
15.5　对象、引用和指针	216
15.5.1　对象的引用	216
15.5.2　对象指针	216
15.6　缩略语和术语表	216
15.7　方法指导	216
15.8　习题	217
第16章　造物者与毁灭者—对象生灭	220
16.1　麻烦的初始化	220
16.2　造物者—构造函数	221
16.2.1　构造函数的声明与定义	221
16.2.2　带参数的构造函数	222
16.3　先有结点，还是先有链表	224
16.4　克隆技术—拷贝构造函数	225
16.4.1　拷贝构造函数	225
16.4.2　默认拷贝构造函数	228
16.4.3　拷贝构造函数存在的意义	228
16.5　毁灭者—析构函数	232
16.6　缩略语和术语表	235
16.7　方法指导	235
16.8　习题	236
第17章　共有财产 好朋友 操作符	239
17.1　有多少个结点	239
17.1.1　静态成员数据	240
17.1.2　静态成员数据的初始化	240
17.1.3　静态成员函数	240
17.2　类的好朋友	243
17.2.1　友元类	243
17.2.2　友元函数	246
17.2.3　友元的利与弊	248
17.3　多功能的操作符—操作符的重载	248
17.3.1　操作符作为成员函数	249
17.3.2　操作符作为友元函数	252
17.3.3　又见加加和减减	254
17.4　缩略语和术语表	256
17.5　方法指导	256
17.6　习题	256
第18章　父与子—类的继承	257
18.1　剑士 弓箭手 法师的困惑	257
18.2　面向对象特点二：继承性	258
18.3　继承的实现	259
18.3.1　私有和保护	259
18.3.2　一个简单的例子	259
18.3.3　继承的方式	261
18.4　子类对象的生灭	265
18.4.1　子类对象的构造	265
18.4.2　子类对象的析构	267
18.5　继承与对象指针	268
18.5.1　父类指针与子类对象	268
18.5.2　猜猜它是谁	269
18.6　面向对象特点三：多态性	270
18.7　多态与虚函数	271
18.7.1　多态的实现	271
18.7.2　无法实现多态的虚函数	273
18.8　虚析构函数	274
18.9　抽象类与纯虚函数	276
18.10　多重继承	278
18.11　缩略语和术语表	279
18.12　方法指导	279
18.13　习题	280
第19章　再谈输入与输出	286
19.1　cout和cin是什么	286
19.2　输入/输出的重定向	286
19.2.1　输入重定向	286
19.2.2　输出重定向	287
19.2.3　无法被重定向的cerr	288
19.3　文件的输入与输出	289
19.4　更巧妙地输入和输出	290
19.4.1　能整行输入的getline	290
19.4.2　能读取判断末尾的eof	291
19.4.3　能计数的gcount	292
19.4.4　能设置域宽的width	292
19.5　插入操作符的重载	293
19.5.1　插入操作符	293
19.5.2　插入操作符的常用重载方式	294
19.6　缩略语和术语表	295
19.7　方法指导	295
19.8　习题	295
第20章　万用的模板	297
20.1　函数模板	297
20.1.1　从为什么需要模板说起	297
20.1.2　声明与定义函数模板	298
20.1.3　函数模板与重载	299
20.2　类模板	301
20.2.1　类模板的声明和定义	301
20.2.2　链表类模板实例	301
20.3　从数组到向量	306
20.3.1　向量的性能	306
20.3.2　对向量的操作	306
20.4　缩略语和术语表	307
20.5　方法技巧	307
20.6　习题	307
第21章  博大精深的STL	312
21.1  STL里有什么	312
21.2  超级指针——迭代器	313
21.3  有了算法，何必还需自己写	314
21.4  从箱子到容器	316
21.4.1  链表，再见！	316
21.4.2  交集和并集	318
21.5  函数也能是对象	320
21.6  空间分配好管家	322
21.7  缩略语和术语表	323
21.8  方法指导	323
21.9  习题	324
附录A　常用保留字列表	326
附录B　常见编译错误和解决方法	328
附录C　参考文献	331
附录D　推荐书目	332
