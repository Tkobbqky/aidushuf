揭秘Java虚拟机-JVM设计原理与实现 PDF下载 封亚飞 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712131541
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712131541
<p>书名:揭秘Java虚拟机-JVM设计原理与实现</p><p>作者:封亚飞</p><p>页数:662</p><p>定价:¥129.0</p><p>出版社:电子工业出版社</p><p>出版日期:2017-07-01</p><p>ISBN:9787121315411</p><p><h2>本书特色</h2></p>[<p>
《揭秘Java虚拟机：JVM设计原理与实现》从源码角度解读HotSpot的内部实现机制，本书主要包含三大部分——JVM数据结构设计与实现、执行引擎机制及内存分配模型。　　数据结构部分包括Java字节码文件格式、常量池解析、字段解析、方法解析。每一部分都给出详细的源码实现分析，例如字段解析一章，从源码层面详细分析了Java字段重排、字段继承等关键机制。再如方法解析一章，给出了Java多态特性在源码层面的实现方式。《揭秘Java虚拟机：JVM设计原理与实现》通过直接对源代码的分析，从根本上梳理和澄清Java领域中的关键概念和机制。　　执行引擎部分包括Java方法调用机制、栈帧创建机制、指令集架构与解释器实现机制。这一话题是《揭秘Java虚拟机：JVM设计原理与实现》技术含量高的部分，需要读者具备一定的汇编基础。不过千万不要被“汇编”这个词给吓着，其实在作者看来，汇编相比于高级语言而言，语法非常简单，语义也十分清晰。执行引擎部分重点描述Java源代码如何转换为字节码，又如何从字节码转换为机器指令从而能够被物理CPU所执行的技术实现。同时详细分析了Java函数堆栈的创建全过程，在源码分析的过程中，带领读者从本质上理解到底什么是Java函数堆栈和栈帧，以及栈帧内部的详细结构。　　内存分配部分主要包括类型创建与加载、对象实例创建与内存分配，例如new关键字的工作机制，import关键字的作用，再如java.lang.ClassLoader.loadClass()接口的本地实现机制。　　《揭秘Java虚拟机：JVM设计原理与实现》并不是简单地分析源码实现，而是在描述HotSpot内部实现机制的同时，分析了HotSpot如此这般实现的技术必然性。读者在阅读《揭秘Java虚拟机：JVM设计原理与实现》的过程中，将会在很多地方看到作者本人的这种思考。
                                        </p>]<p><h2>内容简介</h2></p>[<p>Java是一门非常流行的程序语言，但是，Java程序到底是如何运行的？如何写出更高效的Java代码……？这些令人困扰的问题，都可以从本书中找到答案。
 
随着互联网的极速发展，现在的Java 服务端应用需要应对极高的并发访问和大量的数据交互，如果能深入地理解Java虚拟机的核心原理和实现细节，不仅可以帮助程序员自如地应对变化莫测的各类状况，也可以帮助程序员写出优秀高效的代码。
 
《揭秘Java虚拟机：JVM设计原理与实现》正是这样一部修炼Java内功的武学秘笈。它不仅详细阐述了JVM的设计思路与原理，让读者能够深刻理解JVM的运行机制，而且更进一步地分析了JVM在发展过程中每一次技术选择的必然性——这样的分析让读者得以跨越时空，在思想上与前辈大师们产生共鸣，实现精神上的交流，真正领悟JVM的精髓。
 
更为难得的是，看似艰深莫测的“大道理”，却被作者用晓畅明白、幽默有趣的文字层层化解了：本书在阅读体验上毫无枯燥之感，相反，却能让你在“顿悟”的当下，会心而笑，不忍释卷！
不必犹豫，无须比较，就是它——《揭秘Java虚拟机：JVM设计原理与实现》！
 </p>]<p><h2>作者简介</h2></p>[<p>大学学的是生物技术，但是对计算机保持浓厚兴趣，当年对vb、matlab等语言和工具学的很熟练。毕业后跨界做了软件开发，先后接触了汇编、c、c  、php、asp、java等多种语言，开发过图形库、物联网传感器通信协议、GIS监控定位、电商平台等。进入菜鸟之后，主导结算复杂的业务接入平台化以及业务仿真系统。</p>]<p><h2>目录</h2></p>
    第1章 Java虚拟机概述	11.1  从机器语言到Java——詹爷，你好	11.2  兼容的选择：一场生产力的革命	61.3  中间语言翻译	101.3.1  从中间语言翻译到机器码	111.3.2  通过C程序翻译	111.3.3  直接翻译为机器码	131.3.4  本地编译	161.4  神奇的指令	181.4.1  常见汇编指令	201.4.2  JVM指令	211.5  本章总结	24第2章  Java执行引擎工作原理：方法调用	252.1  方法调用	262.1.1  真实的机器调用	262.1.2  C语言函数调用	412.2  JVM的函数调用机制	472.3  函数指针	532.4  CallStub函数指针定义	602.5  _call_stub_entry例程	722.6  本章总结	115第3章  Java数据结构与面向对象	1173.1  从Java算法到数据结构	1183.2  数据类型简史	1223.3  Java数据结构之偶然性	1293.4  Java类型识别	1323.4.1  class字节码概述	1333.4.2  魔数与JVM内部的int类型	1363.4.3  常量池与JVM内部对象模型	1373.5  大端与小端	1433.5.1  大端和小端的概念	1463.5.2  大小端产生的本质原因	1483.5.3  大小端验证	1493.5.4  大端和小端产生的场景	1513.5.5  如何解决字节序反转	1543.5.6  大小端问题的避免	1563.5.7  JVM对字节码文件的大小端处理	1563.6  本章总结	159第4章  Java字节码实战	1614.1  字节码格式初探	1614.1.1  准备测试用例	1624.1.2  使用javap命令分析字节码文件	1624.1.3  查看字节码二进制	1654.2  魔数与版本	1664.2.1  魔数	1684.2.2  版本号	1684.3  常量池	1694.3.1  常量池的基本结构	1694.3.2  JVM所定义的11种常量	1704.3.3  常量池元素的复合结构	1704.3.4  常量池的结束位置	1724.3.5  常量池元素总数量	1724.3.6  **个常量池元素	1734.3.7  第二个常量池元素	1744.3.8  父类常量	1744.3.9  变量型常量池元素	1754.4  访问标识与继承信息	1774.4.1  access_flags	1774.4.2  this_class	1784.4.3  super_class	1794.4.4  interface	1794.5  字段信息	1804.5.1  fields_count	1804.5.2  field_info fields[fields_count]	1814.6  方法信息	1854.6.1  methods_count	1854.6.2  method_info methods[methods_count]	1854.7  本章回顾	205第5章  常量池解析	2065.1  常量池内存分配	2085.1.1  常量池内存分配总体链路	2095.1.2  内存分配	2155.1.3  初始化内存	2235.2  oop-klass模型	2245.2.1  两模型三维度	2255.2.2  体系总览	2275.2.3  oop体系	2295.2.4  klass体系	2315.2.5  handle体系	2345.2.6  oop、klass、handle的相互转换	2395.3  常量池klass模型（1）	2445.3.1  klassKlass实例构建总链路	2465.3.2  为klassOop申请内存	2495.3.3  klassOop内存清零	2535.3.4  初始化mark	2535.3.5  初始化klassOop._metadata	2585.3.6  初始化klass	2595.3.7  自指	2605.4  常量池klass模型（2）	2615.4.1  constantPoolKlass模型构建	2615.4.2  constantPoolOop与klass	2645.4.3  klassKlass终结符	2675.5  常量池解析	2675.5.1  constantPoolOop域初始化	2685.5.2  初始化tag	2695.5.3  解析常量池元素	2715.6  本章总结	279第6章  类变量解析	2806.1  类变量解析	2816.2  偏移量	2856.2.1  静态变量偏移量	2856.2.2  非静态变量偏移量	2876.2.3  Java字段内存分配总结	3126.3  从源码看字段继承	3196.3.1  字段重排与补白	3196.3.2  private字段可被继承吗	3256.3.3  使用HSDB验证字段分配与继承	3296.3.4  引用类型变量内存分配	3386.4  本章总结	342第7章  Java栈帧	3447.1  entry_point例程生成	3457.2  局部变量表创建	3527.2.1  constMethod的内存布局	3527.2.2  局部变量表空间计算	3567.2.3  初始化局部变量区	3597.3  堆栈与栈帧	3687.3.1  栈帧是什么	3687.3.2  硬件对堆栈的支持	3877.3.3  栈帧开辟与回收	3907.3.4  堆栈大小与多线程	3917.4  JVM的栈帧	3967.4.1  JVM栈帧与大小确定	3967.4.2  栈帧创建	3997.4.3  局部变量表	4217.5  栈帧深度与slot复用	4337.6  *大操作数栈与操作数栈复用	4367.7  本章总结	439第8章  类方法解析	4408.1  方法签名解析与校验	4458.2  方法属性解析	4478.2.1  code属性解析	4478.2.2  LVT＆LVTT	4498.3  创建methodOop	4558.4  Java方法属性复制	4598.5  ＜clinit＞与＜init＞	4618.6  查看运行时字节码指令	4828.7  vtable	4898.7.1  多态	4898.7.2  C  中的多态与vtable	4918.7.3  Java中的多态实现机制	4938.7.4  vtable与invokevirtual指令	5008.7.5  HSDB查看运行时vtable	5028.7.6  miranda方法	5058.7.7  vtable特点总结	5088.7.8  vtable机制逻辑验证	5098.8  本章总结	511第9章  执行引擎	5139.1  执行引擎概述	5149.2  取指	5169.2.1  指令长度	5199.2.2  JVM的两级取指机制	5279.2.3  取指指令放在哪	5329.2.4  程序计数器在哪里	5349.3  译码	5359.3.1  模板表	5359.3.2  汇编器	5409.3.3  汇编	5499.4  栈顶缓存	5589.5  栈式指令集	5659.6  操作数栈在哪里	5769.7  栈帧重叠	5819.8  entry_point例程机器指令	5869.9  执行引擎实战	5889.9.1  一个简单的例子	5889.9.2  字节码运行过程分析	5909.10  字节码指令实现	5979.10.1  iconst_3	5989.10.2  istore_0	5999.10.3  iadd	6009.11  本章总结	601第10章  类的生命周期	60210.1  类的生命周期概述	60210.2  类加载	60510.2.1  类加载——镜像类与静态字段	61110.2.2  Java主类加载机制	61710.2.3  类加载器的加载机制	62210.2.4  反射加载机制	62310.2.5  import与new指令	62410.3  类的初始化	62510.4  类加载器	62810.4.1  类加载器的定义	62810.4.2  系统类加载器与扩展类加载器创建	63410.4.3  双亲委派机制与破坏	63610.4.4  预加载	63810.4.5  引导类加载	64010.4.6  加载、链接与延迟加载	64110.4.7  父加载器	64510.4.8  加载器与类型转换	64810.5  类实例分配	64910.5.1  栈上分配与逃逸分析	65210.5.2  TLAB	65510.5.3  指针碰撞与eden区分配	65710.5.4  清零	65810.5.5  偏向锁	65810.5.6  压栈与取指	65910.6  本章总结	661
