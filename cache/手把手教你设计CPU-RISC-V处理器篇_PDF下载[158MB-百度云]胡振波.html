手把手教你设计CPU-RISC-V处理器篇 PDF下载 胡振波 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711548052
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711548052
<p>书名:手把手教你设计CPU-RISC-V处理器篇</p><p>作者:胡振波</p><p>页数:未知</p><p>定价:¥99.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2018-06-01</p><p>ISBN:9787115480521</p><p><h2>本书特色</h2></p>[<p>
本书是一本介绍通用CPU设计的入门书，以通俗的语言系统介绍了CPU和RISC-V架构，力求为读者揭开CPU设计的神秘面纱，打开计算机体系结构的大门。<br/>本书共分为四部分。*部分是CPU与RISC-V的综述，帮助初学者对CPU和RISC-V快速地建立起认识。第二部分讲解如何使用Verilog设计CPU，使读者掌握处理器核的设计精髓。第三部分主要介绍蜂鸟E203配套的SoC和软件平台，使读者实现蜂鸟E203 RISC-V处理器在FPGA原型平台上的运行。第四部分是附录，介绍了RISC-V指令集架构，辅以作者加入的背景知识解读和注解，以便于读者理解。<br/>本书不仅适合CPU或芯片设计相关从业者阅读使用，也适合作为大中专院校相关师生学习RISC-V处理器设计（使用Verilog语言）和CPU设计的指导用书。
                                        </p>]<p><h2>内容简介</h2></p>[<p>系统介绍RISC-V指令集架构。<br/>结合实际RISC-V开源实例进行教学。<br/>深入剖析RISC-V处理器的微架构以及代码实现。<br/>使读者能够快速掌握并轻松使用RISC-V架构处理器。<br/>通过学习实例蜂鸟E200的Verilog代码，您将能成为一名合格的数字IC设计工程师。通过学习本书推荐的完整开源SoC平台，您也可以快速搭建FPGA原型平台，运行完整的软件实例。 </p>]<p><h2>作者简介</h2></p>[<p>胡振波，上海交通大学电子工程系本科、微电子学院硕士。拥有业界多年ASIC和CPU设计与验证经验，先后在Marvell任职ARM架构CPU设计高级工程师、在Synopsys任职研发经理、在比特大陆任职IC设计总监、在武汉聚芯微电子任职架构师，现致力于推动RISC-V架构在国内的传播和发展。</p>]<p><h2>目录</h2></p>
 第 一部分  CPU与RISC-V综述 第 1章  一文读懂CPU之三生三世	2 1.1　眼看他起高楼，眼看他宴宾客，眼看他楼塌了——CPU众生相	3 1.1.1  ISA——CPU的灵魂	4 1.1.2  CISC与RISC	5 1.1.3  32位与64位架构	6 1.1.4  ISA众生相	6 1.1.5  CPU的领域之分	10 1.2　ISA请扛起这口锅——为什么国产CPU尚未足够成功	12 1.2.1  MIPS系——龙芯和君正	12 1.2.2  x86系——北大众志、兆芯和海光	13 1.2.3  Power系——中晟宏芯	13 1.2.4  Alpha系——申威	14 1.2.5  ARM系——飞腾、华为海思、展讯和华芯通	14 1.2.6  背锅侠ISA	15 1.3　人生已是如此艰难，你又何必拆穿——CPU从业者的无奈	17 1.4　无敌是多么寂寞——ARM统治着的世界	18 1.4.1  独乐乐与众乐乐——ARM公司的盈利模式	18 1.4.2  小个子有大力量——无处不在的Cortex-M系列	21 1.4.3  移动王者——Cortex-A系列在手持设备领域的巨大成功	23 1.4.4  进击的巨人——ARM进军PC与服务器领域的雄心	25 1.5　东边日出西边雨，道是无晴却有晴——RISC-V登场	25 1.6　原来你是这样的“薯片”——ARM的免费计划	28 1.7　旧时王谢堂前燕，飞入寻常百姓家——你也可以设计自己的处理器	28 第 2章  大道至简——RISC-V架构之魂	29 2.1　简单就是美——RISC-V架构的设计哲学	30 2.1.1  无病一身轻——架构的篇幅	30 2.1.2  能屈能伸——模块化的指令集	32 2.1.3  浓缩的都是精华——指令的数量	32 2.2　RISC-V指令集架构简介	33 2.2.1  模块化的指令子集	33 2.2.2  可配置的通用寄存器组	34 2.2.3  规整的指令编码	34 2.2.4  简洁的存储器访问指令	34 2.2.5  高效的分支跳转指令	35 2.2.6  简洁的子程序调用	36 2.2.7  无条件码执行	37 2.2.8  无分支延迟槽	37 2.2.9  零开销硬件循环	38 2.2.10  简洁的运算指令	38 2.2.11  优雅的压缩指令子集	39 2.2.12  特权模式	40 2.2.13  CSR寄存器	40 2.2.14  中断和异常	40 2.2.15  矢量指令子集	40 2.2.16  自定制指令扩展	41 2.2.17  总结与比较	41 2.3　RISC-V软件工具链	42 2.4　RISC-V和其他开放架构有何不同	44 2.4.1  平民英雄——OpenRISC	44 2.4.2  豪门显贵——SPARC	44 2.4.3  名校优生——RISC-V	45 第3章  乱花渐欲迷人眼——盘点RISC-V商业版本与开源版本	46 3.1　各商业版本与开源版本综述	47 3.1.1  Rocket Core（开源）	47 3.1.2  BOOM Core（开源）	49 3.1.3  Freedom SoC（开源）	50 3.1.4  LowRISC SoC（开源）	50 3.1.5  PULPino Core and SoC（开源）	50 3.1.6  PicoRV32 Core（开源）	51 3.1.7  SCR1 Core（开源）	51 3.1.8  ORCA Core（开源）	51 3.1.9  Andes Core（商业IP）	52 3.1.10  Microsemi Core（商业IP）	52 3.1.11  Codasip Core（商业IP）	53 3.1.12  蜂鸟E200 Core与SoC（开源）	53 3.2　总结	53 第4章  开源RISC-V——蜂鸟E200系列超低功耗Core与SoC	54 4.1　与众不同的蜂鸟E200处理器	55 4.2　蜂鸟E200简介——蜂鸟虽小，五脏俱全	56 4.3　蜂鸟E200型号系列	57 4.4　蜂鸟E200性能指标	58 4.5　蜂鸟E200配套SoC	59 4.6　蜂鸟E200配置选项	60 第二部分  手把手教你使用Verilog设计CPU 第5章  先见森林，后观树木——蜂鸟E200设计总览和顶层介绍	65 5.1　处理器硬件设计概述	66 5.1.1  架构和微架构	66 5.1.2  CPU、处理器、Core和处理器核	66 5.1.3  处理器设计和验证的特点	66 5.2　蜂鸟E200处理器核设计哲学	67 5.3　蜂鸟E200处理器核RTL代码风格介绍	68 5.3.1  使用标准DFF模块例化生成寄存器	68 5.3.2  推荐使用assign语法替代if-else和case语法	70 5.3.3  其他若干注意事项	71 5.3.4  小结	72 5.4　蜂鸟E200模块层次划分	72 5.5　蜂鸟E200处理器核源代码	73 5.6　蜂鸟E200处理器核配置选项	73 5.7　蜂鸟E200处理器核支持的RISC-V指令子集	74 5.8　蜂鸟E200处理器流水线结构	74 5.9　蜂鸟E200处理器核顶层接口介绍	74 5.10　总结	77 第6章  流水线不是流水账——蜂鸟E200流水线介绍	78 6.1　处理器流水线概述	79 6.1.1  从经典的五级流水线说起	79 6.1.2  可否不要流水线——流水线和状态机的关系	81 6.1.3  深处种菱浅种稻，不深不浅种荷花——流水线的深度	81 6.1.4  向上生长——越来越深的流水线	82 6.1.5  向下生长——越来越浅的流水线	83 6.1.6  总结	83 6.2　处理器流水线中的乱序	83 6.3　处理器流水线中的反压	84 6.4　处理器流水线中的冲突	84 6.4.1  流水线中的资源冲突	84 6.4.2  流水线中的数据冲突	85 6.5　蜂鸟E200处理器的流水线	86 6.5.1  流水线总体结构	86 6.5.2  流水线中的冲突	87 6.6　总结	87 第7章  万事开头难吗—— 一切从取指令开始	88 7.1　取指概述	89 7.1.1  取指特点	89 7.1.2  如何快速取指	90 7.1.3  如何处理非对齐指令	91 7.1.4  如何处理分支指令	92 7.2　RISC-V架构特点对于取指的简化	97 7.2.1  规整的指令编码格式	97 7.2.2  指令长度指示码放于低位	97 7.2.3  简单的分支跳转指令	98 7.2.4  没有分支延迟槽指令	100 7.2.5  提供明确的静态分支预测依据	100 7.2.6  提供明确的RAS依据	101 7.3　蜂鸟E200处理器的取指实现	101 7.3.1  IFU总体设计思路	102 7.3.2  Mini-Decode	103 7.3.3  Simple-BPU分支预测	105 7.3.4  PC生成	109 7.3.5  访问ITCM和BIU	111 7.3.6  ITCM	115 7.3.7  BIU	116 7.4　总结	116 第8章  一鼓作气，执行力是关键——执行	117 8.1　执行概述	118 8.1.1  指令译码	118 8.1.2  指令执行	118 8.1.3  流水线的冲突	119 8.1.4  指令的交付	119 8.1.5  指令发射、派遣、执行、写回的顺序	119 8.1.6  分支解析	121 8.1.7  小结	121 8.2　RISC-V架构特点对于执行的简化	121 8.2.1  规整的指令编码格式	122 8.2.2  优雅的16位指令	122 8.2.3  精简的指令个数	122 8.2.4  整数指令都是两操作数	122 8.3　蜂鸟E200处理器的执行实现	123 8.3.1  执行指令列表	123 8.3.2  EXU总体设计思路	123 8.3.3  译码	124 8.3.4  整数通用寄存器组	130 8.3.5  CSR寄存器	133 8.3.6  指令发射派遣	134 8.3.7  流水线冲突、长指令和OITF	139 8.3.8  ALU	145 8.3.9  高性能乘除法	157 8.3.10  浮点单元	158 8.3.11  交付	159 8.3.12  写回	159 8.3.13  协处理器扩展	160 8.3.14  小结	160 第9章  善始者实繁，克终者盖寡——交付	161 9.1　处理器交付、取消、冲刷	162 9.1.1  处理器交付、取消、冲刷简介	162 9.1.2  处理器交付常见实现策略	163 9.2　RISC-V架构特点对于交付的简化	164 9.3　蜂鸟E200处理器交付硬件实现	164 9.3.1  分支预测指令的处理	165 9.3.2  中断和异常的处理	168 9.3.3  多周期执行指令的交付	169 9.3.4  小结	169 第 10章  让子弹飞一会儿——写回	170 10.1　处理器的写回	171 10.1.1  处理器写回功能简介	171 10.1.2  处理器写回常见策略	171 10.2　蜂鸟E200处理器的写回硬件实现	171 10.2.1  *终写回仲裁	172 10.2.2  OITF和长指令写回仲裁	174 10.2.3  小结	177 第 11章  哈弗还是比亚迪——存储器架构	178 11.1　存储器架构概述	179 11.1.1  谁说处理器一定要有缓存	179 11.1.2  处理器一定要有存储器	180 11.1.3  ITCM和DTCM	182 11.2　RISC-V架构特点对于存储器访问指令的简化	183 11.2.1  仅支持小端格式	183 11.2.2  无地址自增自减模式	183 11.2.3  无“一次读多个数据”和“一次写多个数据”指令	183 11.3　RISC-V架构的存储器相关指令	184 11.3.1  Load和Store指令	184 11.3.2  Fence指令	184 11.3.3  “A”扩展指令	184 11.4　蜂鸟E200处理器存储器子系统硬件实现	185 11.4.1  存储器子系统总体设计思路	185 11.4.2  AGU	186 11.4.3  LSU	190 11.4.4  ITCM和DTCM	192 11.4.5  “A”扩展指令处理	195 11.4.6  Fence与Fence.I指令处理	200 11.4.7  BIU	202 11.4.8  ECC	202 11.4.9  小结	202 第 12章  黑盒子的窗口——总线接口单元BIU	203 12.1　片上总线协议概述	204 12.1.1  AXI	204 12.1.2  AHB	204 12.1.3  APB	205 12.1.4  TileLink	205 12.1.5  总结比较	205 12.2　自定义总线协议ICB	206 12.2.1  ICB总线协议简介	206 12.2.2  ICB总线协议信号	207 12.2.3  ICB总线协议时序	207 12.3　ICB总线的硬件实现	210 12.3.1  一主多从	210 12.3.2  多主一从	211 12.3.3  多主多从	212 12.4　蜂鸟E200处理器核BIU	212 12.4.1  BIU简介	212 12.4.2  BIU微架构	213 12.4.3  BIU源码分析	214 12.5　蜂鸟E200处理器SoC总线	214 12.5.1  SoC总线简介	215 12.5.2  SoC总线微架构	215 12.5.3  SoC总线源码分析	216 12.6　总结	216 第 13章  不得不说的故事——中断和异常	217 13.1　中断和异常概述	218 13.1.1  中断概述	218 13.1.2  异常概述	219 13.1.3  广义上的异常	219 13.2　RISC-V架构异常处理机制	221 13.2.1  进入异常	221 13.2.2  退出异常	224 13.2.3  异常服务程序	225 13.3　RISC-V架构中断定义	226 13.3.1  中断类型	226 13.3.2  中断屏蔽	228 13.3.3  中断等待	229 13.3.4  中断优先级与仲裁	230 13.3.5  中断嵌套	230 13.3.6  总结比较	231 13.4　RISC-V架构异常相关CSR寄存器	232 13.5　蜂鸟E200异常处理的硬件实现	232 13.5.1  蜂鸟E200处理器的异常和中断实现要点	232 13.5.2  蜂鸟E200处理器的异常类型	233 13.5.3  蜂鸟E200处理器对于mepc的处理	234 13.5.4  蜂鸟E200处理器的中断接口	234 13.5.5  蜂鸟E200处理器CLINT微架构及源码分析	235 13.5.6  蜂鸟E200处理器PLIC微架构及源码分析	238 13.5.7  蜂鸟E200处理器交付模块对中断和异常的处理	242 13.5.8  小结	245 第 14章  *不起眼的，其实是*难的——调试机制	246 14.1　调试机制概述	247 14.1.1  交互调试概述	247 14.1.2  跟踪调试概述	249 14.2　RISC-V架构的调试机制	249 14.2.1  调试器软件的实现	250 14.2.2  调试模式	250 14.2.3  调试指令	251 14.2.4  调试机制CSR	251 14.2.5  调试中断	251 14.3　蜂鸟E200调试机制的硬件实现	251 14.3.1  蜂鸟E200交互式调试概述	251 14.3.2  DTM模块	253 14.3.3  硬件调试模块	253 14.3.4  调试中断处理	257 14.3.5  调试机制CSR寄存器的实现	258 14.3.6  调试机制指令的实现	258 14.3.7  小结	259 第 15章  动如脱兔，静若处子——低功耗的诀窍	260 15.1　处理器低功耗技术概述	261 15.1.1  软件层面低功耗	261 15.1.2  系统层面低功耗	261 15.1.3  处理器层面低功耗	262 15.1.4  单元层面低功耗	262 15.1.5  寄存器层面低功耗	263 15.1.6  锁存器层面低功耗	264 15.1.7  SRAM层面低功耗	264 15.1.8  组合逻辑层面低功耗	264 15.1.9  工艺层面低功耗	265 15.2　RISC-V架构的低功耗机制	265 15.3　蜂鸟E200低功耗机制的硬件实现	265 15.3.1  蜂鸟E200系统层面低功耗	265 15.3.2  蜂鸟E200处理器层面低功耗	267 15.3.3  蜂鸟E200单元层面低功耗	269 15.3.4  蜂鸟E200寄存器层面低功耗	269 15.3.5  蜂鸟E200锁存器层面低功耗	272 15.3.6  蜂鸟E200 SRAM层面低功耗	273 15.3.7  蜂鸟E200组合逻辑层面低功耗	274 15.3.8  蜂鸟E200工艺层面低功耗	275 15.4　总结	275 第 16章  工欲善其事，必先利其器——RISC-V可扩展协处理器	276 16.1　专用领域架构DSA	277 16.2　RISC-V架构的可扩展性	278 16.2.1  RISC-V的预留指令编码空间	278 16.2.2  RISC-V的预定义的Custom指令	279 16.3　蜂鸟E200的协处理器接口EAI	279 16.3.1  EAI指令的编码	279 16.3.2  EAI接口信号	280 16.3.3  EAI流水线接口	281 16.3.4  EAI存储器接口	282 16.3.5  EAI接口时序	283 16.4　蜂鸟E200的协处理器参考示例	286 16.4.1  示例协处理器需求	286 16.4.2  示例协处理器指令	287 16.4.3  示例协处理器实现	288 16.4.4  示例协处理器性能	289 16.4.5  示例协处理器代码	290 第三部分  使用Verilog进行仿真和在FPGA SoC原型上运行软件 第 17章  冒个烟先——运行Verilog仿真测试	292 17.1　E200开源项目的代码层次结构	293 17.2　E200开源项目的测试用例	294 17.2.1  riscv-tests 自测试用例	294 17.2.2  编译ISA自测试用例	295 17.3　E200开源项目的测试平台（TestBench）	298 17.4　在Verilog TestBench中运行测试用例	299 第 18章  套上壳子上路——实现SoC和FPGA原型	302 18.1　Freedom E310 SoC简介	303 18.2　HBird-E200-SoC简介	304 18.2.1  HBird-E200-SoC组成结构	304 18.2.2  HBird-E200-SoC代码结构	309 18.3　HBird-E200-SoC FPGA原型平台	311 18.3.1  FPGA开发板	311 18.3.2  生成mcs文件烧写FPGA	314 18.3.3  JTAG调试器	317 18.3.4  FPGA原型平台DIY总结	320 18.4　蜂鸟E200专用FPGA开发板	320 第 19章  画龙点睛——运行和调试软件示例	321 19.1　Freedom-E-SDK平台简介	322 19.2　SIRV-E-SDK平台简介	323 19.2.1  SIRV-E-SDK简介	323 19.2.2  SIRV-E-SDK代码结构	324 19.3　使用SIRV-E-SDK运行示例程序	325 19.4　使用GDB和OpenOCD调试示例程序	328 19.5　Windows图形化IDE开发工具	331 第 20章  是骡子是马？拉出来遛遛——运行跑分程序	332 20.1　跑分程序简介	333 20.2　Dhrystone简介	333 20.3　运行Dhrystone Benchmark	335 20.4　CoreMark简介	337 20.5　运行CoreMark Benchmark	338 20.6　总结与比较	340 附录部分  RISC-V架构详述 附录A  RISC-V架构指令集介绍	342 附录B  RISC-V架构CSR寄存器介绍	374 附录C  RISC-V架构的PLIC介绍	384 附录D  存储器模型背景介绍	392 附录E  存储器原子操作指令背景介绍	397 附录F  RISC-V指令编码列表	400 附录G  RISC-V伪指令列表	404
