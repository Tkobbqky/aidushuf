操作系统真象还原 PDF下载 郑钢 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711541434
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711541434
<p>书名:操作系统真象还原</p><p>作者:郑钢</p><p>页数:759</p><p>定价:¥108.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2016-03-01</p><p>ISBN:9787115414342</p><p><h2>相关资料</h2></p>[<p>作者用轻松、诙谐的语言讲解了高深的操作系统原理。通俗易懂、深入浅出，从操作系统设计思想的角度出发，授人以渔。同时，又密切结合典型实例，透彻展示出操作系统的架构设计是如何设计出来的，从而让读者真正掌握操作系统的强大之处。书中不含较为复杂的技术理论问题，一切从实际出发。</p>]<p><h2>本书特色</h2></p>[<p>
本书共分16章，讲解了开发一个操作系统需要的技术和知识，主要内容有：操作系统基础、部署工作环境、编写mbr主引导记录、完善mbr错误、保护模式入门、保护模式进阶和向内核迈进、中断、内存管理系统、线程、输入输出系统、用户进程、完善内核、编写硬盘驱动程序、文件系统、系统交互等核心技术。本书适合程序员、系统底层开发人员、操作系统爱好者阅读，也可作为大专院校相关专业师生用书和培训学校的教材。
                                        </p>]<p><h2>内容简介</h2></p>[<p>前百度高级工程师精心写作。操作系统并不深奥，本书给予解读。历时19个月，行文60余万字，用6000多行代码实现了一个完整的操作系统。彻底剖析操作系统的原理，实现内核线程、特权级变换、用户进程、任务调度、文件系统等操作系统基本的组成单元。用实际代码解释了锁、信号量、生产者消费者问题。实现了shell，帮助大家理解内部命令、外部命令、管道等操作。本书用诙谐幽默的语言，把深奥的操作系统尽量讲解清楚，读者在轻松阅读中就学通了深奥的知识，学完后不但明白了操作系统，读者可以轻松自制一个操作系统，是一本难得的好书。本书适合操作系统快速入门并希望快速提高的读者、具备一定基础、但不能灵活运用的读者、也适用于那些已经在操作系统领域有一定造诣、但依然存在误用的读者绝大多数技术人都对操作系统怀着好奇的心，他们渴望一本告诉操作系统到底是什么的书，里面不要掺杂太多无关的管理性的东西，代码量不大且是现代操作系统雏形，渴望很快看到操作系统的本质而不花费大量的时间成本。操作系统并不深奥，本书给予解读。 </p>]<p><h2>作者简介</h2></p>[<p>郑钢，毕业于北京大学，前百度运维高级工程师，对操作系统有深入的研究。好运动，喜钻研，热衷于尝试前沿技术，乐于分享学习成果。</p>]<p><h2>目录</h2></p>
    第0章　一些你可能正感到迷惑的问题0.1  操作系统是什么	10.2  你想研究到什么程度	20.3  写操作系统，哪些需要我来做	20.4  软件是如何访问硬件的	20.5  应用程序是什么，和操作系统是如何配合到一起的	30.6  为什么称为“陷入”内核	40.7  内存访问为什么要分段	40.8  代码中为什么分为代码段、数据段？这和内存访问机制中的段是一回事吗	60.9  物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别	110.10  什么是段重叠	120.11  什么是平坦模型	120.12  cs、ds这类sreg段寄存器，位宽是多少	120.13  什么是工程，什么是协议	130.14  为什么linux系统下的应用程序不能在windows系统下运行	140.15  局部变量和函数参数为什么要放在栈中	140.16  为什么说汇编语言比c语言快	150.17  先有的语言，还是先有的编译器，第1个编译器是怎么产生的	160.18  编译型程序与解释型程序的区别	190.19  什么是大端字节序、小端字节序	190.20  bios中断、dos中断、linux中断的区别	210.21  section和segment的区别	250.22  什么是魔数	290.23  操作系统是如何识别文件系统的	300.24  如何控制cpu的下一条指令	300.25  指令集、体系结构、微架构、编程语言	300.26  库函数是用户进程与内核的桥梁	330.27  转义字符与ascii码	370.28  mbr、ebr、dbr和obr各是什么	39第1章  部署工作环境	421.1  工欲善其事，必先利其器	421.2  我们需要哪些编译器	421.2.1  世界顶级编译器gcc	421.2.2  汇编语言编译器新贵nasm	431.3  操作系统的宿主环境	431.3.1  什么是虚拟机	441.3.2  盗梦空间般的开发环境，虚拟机中再装一个虚拟机	451.3.3  virtualbox下载，安装	461.3.4  linux发行版下载	461.3.5  bochs下载安装	461.4  配置bochs	481.5  运行bochs	49第2章  编写mbr主引导记录，让我们开始掌权	522.1  计算机的启动过程	522.2  软件接力**棒，bios	522.2.1  实模式下的1mb内存布局	522.2.2  bios是如何苏醒的	542.2.3  为什么是0x7c00	562.3  让mbr先飞一会儿	582.3.1  神奇好用的$和$$，令人迷惑的section	582.3.2  nasm简单用法	602.3.3  请下一位选手mbr同学做准备	60第3章  完善mbr	653.1  地址、section、vstart浅尝辄止	653.1.1  什么是地址	653.1.2  什么是section	673.1.3  什么是vstart	683.2  cpu的实模式	703.2.1  cpu的工作原理	713.2.2  实模式下的寄存器	723.2.3  实模式下内存分段由来	763.2.4  实模式下cpu内存寻址方式	783.2.5  栈到底是什么玩意儿	813.2.6  实模式下的ret	843.2.7  实模式下的call	853.2.8  实模式下的jmp	923.2.9  标志寄存器flags	973.2.10  有条件转移	993.2.11  实模式小结	1013.3  让我们直接对显示器说点什么吧	1013.3.1  cpu如何与外设通信—io接口	1013.3.2  显卡概述	1053.3.3  显存、显卡、显示器	1063.3.4  改进mbr，直接操作显卡	1103.4  bochs调试方法	1123.4.1  bochs一般用法	1133.4.2  bochs调试实例	1183.5  硬盘介绍	1223.5.1  硬盘发展简史	1223.5.2  硬盘工作原理	1233.5.3  硬盘控制器端口	1263.5.4  常用的硬盘操作方法	1283.6  让mbr使用硬盘	1293.6.1  改造mbr	1303.6.2  实现内核加载器	134第4章  保护模式入门	1364.1  保护模式概述	1364.1.1  为什么要有保护模式	1364.1.2  实模式不是32位cpu，变成了16位	1374.2  初见保护模式	1374.2.1  保护模式之寄存器扩展	1374.2.2  保护模式之寻址扩展	1404.2.3  保护模式之运行模式反转	1414.2.4  保护模式之指令扩展	1454.3  全局描述符表	1504.3.1  段描述符	1504.3.2  全局描述符表gdt、局部描述符表ldt及选择子	1554.3.3  打开a20地址线	1574.3.4  保护模式的开关，cr0寄存器的pe位	1584.3.5  让我们进入保护模式	1584.4  处理器微架构简介	1654.4.1  流水线	1664.4.2  乱序执行	1684.4.3  缓存	1684.4.4  分支预测	1694.5  使用远跳转指令清空流水线，更新段描述符缓冲寄存器	1724.6  保护模式之内存段的保护	1734.6.1  向段寄存器加载选择子时的保护	1734.6.2  代码段和数据段的保护	1744.6.3  栈段的保护	175第5章  保护模式进阶，向内核迈进	1775.1  获取物理内存容量	1775.1.1  学习linux获取内存的方法	1775.1.2  利用bios中断0x15子功能0xe820获取内存	1775.1.3  利用bios中断0x15子功能0xe801获取内存	1795.1.4  利用bios中断0x15子功能0x88获取内存	1805.1.5  实战内存容量检测	1815.2  启用内存分页机制，畅游虚拟空间	1865.2.1  内存为什么要分页	1865.2.2  一级页表	1885.2.3  二级页表	1925.2.4  规划页表之操作系统与用户进程的关系	1975.2.5  启用分页机制	1985.2.6  用虚拟地址访问页表	2045.2.7  快表tlb（translation lookasidebuffer）简介	2065.3  加载内核	2075.3.1  用c语言写内核	2075.3.2  二进制程序的运行方法	2115.3.3  elf格式的二进制文件	2135.3.4  elf文件实例分析	2185.3.5  将内核载入内存	2225.4  特权级深入浅出	2295.4.1  特权级那点事	2295.4.2  tss简介	2305.4.3  cpl和dpl入门	2325.4.4  门、调用门与rpl序	2355.4.5  调用门的过程保护	2405.4.6  rpl的前世今生	2435.4.7  io特权级	248第6章  完善内核	2526.1  函数调用约定简介	2526.2  汇编语言和c语言混合编程	2566.2.1  浅析c库函数与系统调用	2566.2.2  汇编语言和c语言共同协作	2596.3  实现自己的打印函数	2616.3.1  显卡的端口控制	2616.3.2  实现单个字符打印	2656.3.3  实现字符串打印	2756.3.4  实现整数打印	2776.4  内联汇编	2816.4.1  什么是内联汇编	2816.4.2  汇编语言at&t语法简介	2816.4.3  基本内联汇编	2836.4.4  扩展内联汇编	2846.4.5  扩展内联汇编之机器模式简介	294第7章  中断	2987.1  中断是什么，为什么要有中断	2987.2  操作系统是中断驱动的	2997.3  中断分类	2997.3.1  外部中断	2997.3.2  内部中断	3017.4  中断描述符表	3047.4.1  中断处理过程及保护	3067.4.2  中断发生时的压栈	3087.4.3  中断错误码	3107.5  可编程中断控制器8259a	3117.5.1  8259a介绍	3117.5.2  8259a的编程	3147.6  编写中断处理程序	3197.6.1  从*简单的中断处理程序开始	3197.6.2  改进中断处理程序	3357.6.3  调试实战：处理器进入中断时压栈出栈完整过程	3397.7  可编程计数器/定时器8253简介	3467.7.1  时钟—给设备打拍子	3467.7.2  8253入门	3487.7.3  8253控制字	3497.7.4  8253工作方式	3507.7.5  8253初始化步骤	3537.8  提高时钟中断的频率，让中断来得更猛烈一些	354第8章  内存管理系统	3578.1  makefile简介	3578.1.1  makefile是什么	3578.1.2  makefile基本语法	3588.1.3  跳到目标处执行	3608.1.4  伪目标	3618.1.5  make：递归式推导目标	3628.1.6  自定义变量与系统变量	3638.1.7  隐含规则	3658.1.8  自动化变量	3668.1.9  模式规则	3678.2  实现assert断言	3678.2.1  实现开、关中断的函数	3678.2.2  实现assert	3708.2.3  通过makefile来编译	3728.3  实现字符串操作函数	3748.4  位图bitmap及其函数的实现	3778.4.1  位图简介	3778.4.2  位图的定义与实现	3788.5  内存管理系统	3818.5.1  内存池规划	3818.5.2  内存管理系统**步，分配页内存	388第9章  线程	3989.1  实现内核线程	3989.1.1  执行流	3989.1.2  线程到底是什么	3999.1.3  进程与线程的关系、区别简述	4029.1.4  进程、线程的状态	4059.1.5  进程的身份证—pcb	4059.1.6  实现线程的两种方式—内核或用户进程	4069.2  在内核空间实现线程	4099.2.1  简单的pcb及线程栈的实现	4099.2.2  线程的实现	4139.3  核心数据结构，双向链表	4179.4  多线程调度	4219.4.1  简单优先级调度的基础	4219.4.2  任务调度器和任务切换	425第10章  输入输出系统	43910.1  同步机制——锁	43910.1.1  排查gp异常，理解原子操作	43910.1.2  找出代码中的临界区、互斥、竞争条件	44410.1.3  信号量	44510.1.4  线程的阻塞与唤醒	44710.1.5  锁的实现	44910.2  用锁实现终端输出	45210.3  从键盘获取输入	45610.3.1  键盘输入原理简介	45610.3.2  键盘扫描码	45710.3.3  8042简介	46310.3.4  测试键盘中断处理程序	46510.4  编写键盘驱动	46810.4.1  转义字符介绍	46810.4.2  处理扫描码	46910.5  环形输入缓冲区	47610.5.1  生产者与消费者问题简述	47610.5.2  环形缓冲区的实现	47810.5.3  添加键盘输入缓冲区	48110.5.4  生产者与消费者实例测试	482第11章  用户进程	48511.1  为什么要有任务状态段tss	48511.1.1  多任务的起源，很久很久以前…… 	48511.1.2  ldt简介	48611.1.3  tss的作用	48811.1.4  cpu原生支持的任务切换方式	49211.1.5  现代操作系统采用的任务切换方式	49511.2  定义并初始化tss	49711.3  实现用户进程	50111.3.1  实现用户进程的原理	50111.3.2  用户进程的虚拟地址空间	50111.3.3  为进程创建页表和3特权级栈	50211.3.4  进入特权级3	50511.3.5  用户进程创建的流程	50611.3.6  实现用户进程—上	50711.3.7  bss简介	51311.3.8  实现用户进程—下	51511.3.9  让进程跑起来—用户进程的调度	51911.3.10  测试用户进程	520第12章  进一步完善内核	52312.1  linux系统调用浅析	52312.2  系统调用的实现	52712.2.1  系统调用实现框架	52712.2.2  增加0x80号中断描述符	52712.2.3  实现系统调用接口	52812.2.4  增加0x80号中断处理例程	52812.2.5  初始化系统调用和实现sys_getpid	53012.2.6  添加系统调用getpid	53112.2.7  在用户进程中的系统调用	53212.2.8  系统调用之栈传递参数	53412.3  让用户进程“说话”	53612.3.1  可变参数的原理	53612.3.2  实现系统调用write	53812.3.3  实现printf	53912.3.4  完善printf	54212.4  完善堆内存管理	54512.4.1  malloc底层原理	54512.4.2  底层初始化	54812.4.3  实现sys_malloc	55012.4.4  内存的释放	55512.4.5  实现sys_free	55812.4.6  实现系统调用malloc和free	562第13章  编写硬盘驱动程序	56613.1  硬盘及分区表	56613.1.1  创建从盘及获取安装的磁盘数	56613.1.2  创建磁盘分区表	56713.1.3  磁盘分区表浅析	57113.2  编写硬盘驱动程序	57813.2.1  硬盘初始化	57813.2.2  实现thread_yield和idle线程	58213.2.3  实现简单的休眠函数	58413.2.4  完善硬盘驱动程序	58513.2.5  获取硬盘信息，扫描分区表	590第14章  文件系统	59514.1  文件系统概念简介	59514.1.1  inode、间接块索引表、文件控制块fcb简介	59514.1.2  目录项与目录简介	59714.1.3  超级块与文件系统布局	59914.2  创建文件系统	60114.2.1  创建超级块、i结点、目录项	60114.2.2  创建文件系统	60314.2.3  挂载分区	60914.3  文件描述符简介	61214.3.1  文件描述符原理	61214.3.2  文件描述符的实现	61414.4  文件操作相关的基础函数	61514.4.1  inode操作有关的函数	61614.4.2  文件相关的函数	62014.4.3  目录相关的函数	62314.4.4  路径解析相关的函数	62814.4.5  实现文件检索功能	63014.5  创建文件	63314.5.1  实现file_create	63314.5.2  实现sys_open	63614.5.3  在文件系统上创建第1个文件	63914.6  文件的打开与关闭	64014.6.1  文件的打开	64014.6.2  文件的关闭	64214.7  实现文件写入	64314.7.1  实现file_write	64314.7.2  改进sys_write及write系统调用	64814.7.3  把数据写入文件	65014.8  读取文件	65114.8.1  实现file_read	65114.8.2  实现sys_read与功能验证	65314.9  实现文件读写指针定位功能	65514.10  实现文件删除功能	65714.10.1  回收inode	65714.10.2  删除目录项	66014.10.3  实现sys_unlink与功能验证	66314.11  创建目录	66514.11.1  实现sys_mkdir创建目录	66614.11.2  创建目录功能验证	66914.12  遍历目录	67114.12.1  打开目录和关闭目录	67114.12.2  读取1个目录项	67314.12.3  实现sys_readdir及sys_rewinddir	67414.13  删除目录	67614.13.1  删除目录与判断空目录	67614.13.2  实现sys_rmdir及功能验证	67714.14  任务的工作目录	67914.14.1  显示当前工作目录的原理及基础代码	67914.14.2  实现sys_getcwd	68114.14.3  实现sys_chdir改变工作目录	68314.15  获得文件属性	68414.15.1  ls命令的幕后功臣	68414.15.2  实现sys_stat	685第15章  系统交互	68715.1  fork的原理与实现	68715.1.1  什么是fork	68715.1.2  fork的实现	68915.1.3  添加fork系统调用与实现init进程	69515.2  添加read系统调用，获取键盘输入	69615.3  添加putchar、clear系统调用	69715.4  实现一个简单的shell	69915.4.1  shell雏形	69915.4.2  添加ctrl u和ctrl l快捷键	70115.4.3  解析键入的字符	70315.4.4  添加系统调用	70515.4.5  路径解析转换	70815.4.6  实现ls、cd、mkdir、ps、rm等命令	71215.5  加载用户进程	71715.5.1  实现exec	71715.5.2  让shell支持外部命令	72315.5.3  加载硬盘上的用户程序执行	72415.5.4  使用户进程支持参数	72715.6  实现系统调用wait和exit	73115.6.1  wait和exit的作用	73115.6.2  孤儿进程和僵尸进程	73215.6.3  一些基础代码	73315.6.4  实现wait和exit	73715.6.5  实现cat命令	74115.7  管道	74515.7.1  管道的原理	74515.7.2  管道的设计	74715.7.3  管道的实现	74815.7.4  利用管道实现进程间通信	75215.7.5  在shell中支持管道	754参考文献	760
