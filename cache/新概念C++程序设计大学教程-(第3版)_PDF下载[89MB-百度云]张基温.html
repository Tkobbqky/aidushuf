新概念C++程序设计大学教程-(第3版) PDF下载 张基温 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730248154
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730248154
<p>书名:新概念C++程序设计大学教程-(第3版)</p><p>作者:张基温</p><p>页数:404</p><p>定价:¥49.8</p><p>出版社:清华大学出版社</p><p>出版日期:2018-01-01</p><p>ISBN:9787302481546</p><p><h2>本书特色</h2></p>[<p>
本书是一本面向大学计算机专业的C  程序设计教材，以面向对象程序设计为主线，突出C  的基本特点，介绍C  1y的重要新特性。全书共分为4篇11个单元。
第1篇：C  面向对象起步。用4个单元帮助初学者建立面向对象的问题分析思维，掌握相关方法和语法知识，树立面向对象程序中“一切皆对象，一切来自类”的意识，初步领略面向对象程序设计的奥妙。
第2篇：C  面向抽象程序设计。用两个单元介绍C  的继承机制，并帮助读者理解如何在一个程序中组织类，以及什么样的类结构才是好的程序结构。
第3篇：C  泛型程序设计。用两个单元介绍多态性和STL。C  的泛型的通用、灵活的特点将给读者的学习带来一定乐趣，也为读者将来从事程序开发工作提供了更多便捷方法。
第4篇：C  深入编程。用3个单元介绍C  实体访问、函数和I/O流等方面的细节和内容，进一步丰富程序设计语言机制，使读者在程序开发上能够锦上添花。
本书理念先进、概念清晰、讲解透彻、便于理解。书中例题经典、习题丰富、覆盖面广，适合作为高等学校各专业的面向对象程序设计教材。本书还可供培训机构使用，也可供相关领域人员自学。
                                        </p>]<p><h2>内容简介</h2></p>[<p>零起点，实例引导，轻松入门，逐步深入。? 凸出面向对象思维，彰显C  精彩，靠拢C   1y。? 注重面向对象的思维训练和语言艺术的发挥。? 提倡探索式学习。? 弹性大，余味长，鼓励创新，适合多层次教学。? 大题量、多类型、宽覆盖面。 </p>]<p><h2>作者简介</h2></p>[<p>张基温 研究和教学领域涉及计算机科学与技术、信息管理、信息经济学、电子政务与电子商务、服务科学，发表论文百余篇，出版著作百余种；先后担任名古屋大学访问学者，山西财经大学、江南大学、华东政法大学、华南农业大学珠江学院、常熟理工学院、福建工程学院、广西职业技术学院、晋城学院等多所大学的专职、客座或兼职教授，北京大学博雅方略城市发展与信息化研究中心研究员，南京大学出版社总编顾问，太原高新技术区IT研究院实验室主任，山西省紧缺人才专家委员会副主任等职，中国信息经济学会常务理事，全国高等院校计算机基础教育研究会常务理事兼课程建设委员会副主任，中国计算机学会教育专业委员会委员，NIT考试委员会委员，江苏省计算机基础教学指导委员会委员，山西省新世纪专家学者协会副会长；为清华大学出版社、电子工业出版社、中国水利水电出版社、南京大学出版社等出版社主编了信息管理与信息系统专业、计算机实验与实践、大学生信息素养等多个系列教材，已经发表论文百余篇，出版著作百余种。在程序设计教学领域，从20世纪80年代初就开始进行有关研究和改革，尝试将软件工程方法和算法思想引入程序设计，倡导“从语法体系向问题体系转变”、“程序设计 = 思维训练   语言艺术   工程规范”，率先把设计模式及其有关原则引入到面向对象的程序设计教材中。</p>]<p><h2>目录</h2></p>
    目录
第1篇  C  面向对象起步
第1单元  职员类          3
1.1  从具体对象到职员类   3
1.1.1 
具体职员对象的分析与描述    3
1.1.2 
Employee类的声明    4
1.1.3 
C  保留字、标识符与名字空间      5
1.2 
C  基本数据类型 7
1.2.1 
C  算术数据类型的表示格式  7
1.2.2 
C  算术数据类型的取值范围  9
1.2.3 
C  运算符与算术数据类型的操作集合  10
1.3  表达式   11
1.3.1 
字面值         11
1.3.2 
数据实体    11
1.3.3 
含有操作符的表达式         13
1.3.4 
表达式中的隐式数据类型转换         14
1.4  函数        15
1.4.1 
函数的关键环节         15
1.4.2 
标准输出流cout与printEmployee() 函数       17
1.4.3 
构造函数与析构函数         18
1.4.4 
构造函数重载    21
1.4.5 
复制构造函数    22
1.4.6 
主函数         24
1.5  程序编译        26
1.5.1 
编译预处理         26
1.5.2 
编译和连接         28
1.5.3 
多文件程序的编译    28
1.6  知识链接        30
1.6.1 
C  字面值  30
1.6.2 
const符号常量  33
1.6.3 
指针=基类型 地址    34
1.6.4 
指向对象的指针与this      36
1.6.5 
引用    38
习题1      39
第2单元  简单计算器          44
2.1  简单计算器建模   44
2.1.1 
简单计算器分析         44
2.1.2 
Calculator类的声明   44
2.2 
calculate( )函数的实现 45
2.2.1 
布尔类型与关系运算符    45
2.2.2 
用if-else结构实现成员函数calculate( )  46
2.2.3 
用switch结构实现calculate( ) 48
2.2.4 
if-else判断结构与switch判断结构比较 49
2.2.5 
Calculator类测试       49
2.3 
C  异常处理 52
2.3.1 
程序错误    52
2.3.2 
C  异常处理机制      54
2.3.3 
C  异常处理技术      55
2.3.4 
用类作为异常类型    58
2.3.5 
捕获任何异常    62
2.4  简单桌面计算器的改进        63
2.4.1 
使用浮点数计算的Calculator类      63
2.4.2 
标准输入流与键盘输入    64
2.4.3 
简单多项式计算的实现    67
2.4.4 
用重复结构实现任意多项式计算    72
2.5  知识链接        74
2.5.1 
条件表达式         74
2.5.2 
局部变量    74
2.5.3 
类属变量、实例变量与局部变量的比较         76
习题2      76
第3单元  素数产生器          81
3.1  问题描述与对象建模   81
3.1.1 
对象建模    81
3.1.2 
getPrimeSequence( )函数的基本思路       82
3.2  使用isPrime( )的PrimeGenerator类实现   82
3.2.1 
用for结构实现的getPrimeSequence( )函数    82
3.2.2 
用for结构实现的isPrime( )函数      84
3.2.3 
完整的PrimeGenerator类及其测试         84
3.3  不使用isPrime( )的PrimeGenerator类实现        85
3.3.1 
采用嵌套重复结构的getPrimeSequence( )函数      85
3.3.2 
重复结构中的continue语句和break语句      86
3.4  数组        87
3.4.1 
数组及其定义    87
3.4.2 
数组的初始化规则    89
3.4.3 
用数组存储素数序列         90
3.4.4 
sizeof操作符      91
3.4.5 
C  11中基于容器的for循环   91
3.4.6 
数组prime的声明     92
3.5 
string类型     94
3.6  知识链接        94
3.6.1 
C  操作符  94
3.6.2 
左值表达式与右值表达式         96
3.6.3 
具有副作用的表达式与序列点         97
3.6.4 
表达式类型的推断与获取：auto 与decltype         98
3.6.5 
类型转换构造函数与explicit关键字        101
3.6.6 
C  语句      105
习题3      105
第4单元  Time类         110
4.1 
Time类需求分析与操作符重载  110
4.1.1 
Time类需求分析        110
4.1.2 
关键字operator与操作符重载         111
4.1.3 
操作符 的重载  112
4.1.4 
增量操作符  的重载         113
4.1.5  用友元函数实现
4.1.6 
赋值操作符=的重载  117
4.1.7 
操作符重载的基本规则    118
4.1.8 
Time类的类型转换构造函数   120
4.2  浅复制与深复制   122
4.2.1 
数据复制及其问题    122
4.2.2 
复制构造函数再讨论         124
4.2.3 
深复制的赋值操作符重载         126
4.3  动态内存分配        127
4.3.1 
用new进行动态内存分配        127
4.3.2 
用delete释放动态存储空间    128
4.3.3 
对象的动态存储分配         129
4.3.4 
动态内存分配时的异常处理    131
4.4  对象数组        132
4.4.1 
对象数组的定义         132
4.4.2 
对象数组元素的访问         133
4.4.3 
数组存储空间的动态分配         134
4.5  知识链接        134
4.5.1 
友元    134
4.5.2 
const修饰类成员与对象  138
4.5.3 
enum类型  140
习题4      144
第2篇  C  面向抽象程序设计
第5单元  继承     153
5.1  单基继承        153
5.1.1 
公司人员的类层次结构模型    153
5.1.2 
C  继承关系的建立  153
5.1.3 
在派生类中重定义基类成员函数    157
5.1.4 
基于血缘关系的访问控制——protected         159
5.1.5 
类层次结构中构造函数和析构函数的执行顺序    160
5.2  类层次中的赋值兼容规则与里氏代换原则        163
5.2.1 
类层次中的类型赋值兼容规则         163
5.2.2 
里氏代换原则    164
5.2.3 
对象的向上转换和向下转换    164
5.3  多基继承        165
5.3.1 
C  多基继承格式      165
5.3.2 
计算机系统=软件 硬件问题的类结构    165
5.3.3 
多基继承的歧义性问题    167
5.3.4 
虚拟基类    169
5.4  用虚函数实现动态绑定        170
5.4.1 
画圆、三角形和矩形问题的类结构         170
5.4.2 
虚函数与动态绑定    171
5.4.3 
虚函数表与虚函数规则    173
5.4.4 
override和final  175
5.4.5 
纯虚函数与抽象类    177
5.5  运行时类型鉴别   179
5.5.1 
RTTI概述    179
5.5.2 
dynamic_cast      179
5.5.3 
type_info类与typeid操作符     185
习题5      188
 
第6单元  C  程序结构优化       195
6.1  面向对象程序设计的几个原则   195
6.1.1 
引言    195
6.1.2 
从可重用说起：合成/聚合优先原则       197
6.1.3 
从可维护性说起：开闭原则    199
6.1.4 
面向抽象原则    201
6.1.5 
单一职责原则    207
6.1.6 
接口分离原则    208
6.1.7 
不要和陌生人说话    212
6.2 
GoF设计模式举例：工厂模式    214
6.2.1 
概述    214
6.2.2 
简单工厂模式    215
6.2.3 
工厂方法模式    217
习题6      219
第3篇  C  泛型程序设计
第7单元  模板     223
7.1  算法抽象模板--函数模板     223
7.1.1 
从函数重载到函数模板    223
7.1.2 
函数模板的实例化与具体化    224
7.2  数据抽象模板--类模板 227
7.2.1 
类模板的定义    227
7.2.2 
类模板的实例化与具体化         228
7.2.3 
类模板的使用    230
7.2.4 
类模板实例化时的异常处理    231
7.2.5 
实例：MyVector模板类的设计        232
习题7      236
第8单元  STL编程       242
8.1 
STL概述 242
8.1.1 
容器    242
8.1.2 
迭代器         244
8.1.3 
容器的成员函数         247
8.1.4 
STL算法      250
8.1.5 
函数对象    253
8.1.6 
STL标准头文件  255
8.2  扑克游戏——vector容器应用实例    256
8.2.1 
vector容器的特点     256
8.2.2 
扑克游戏对象模型    256
8.2.3 
用vector容器对象poker存储54张扑克牌    257
8.2.4 
洗牌函数设计    260
8.2.5 
整牌函数设计    263
8.2.6 
发牌函数设计    264
8.2.7 
vector操作小结 267
8.3 
list容器及其应用实例 268
8.3.1 
构建list对象及其迭代器 268
8.3.2 
操作list对象      269
8.3.3 
基于list容器的约瑟夫斯问题求解 273
8.4 
string      276
8.4.1 
字符串对象的创建与特性描述         277
8.4.2 
字符串对象的输入/输出   277
8.4.3 
字符串的迭代器与字符操作    278
8.4.4 
两个字符串间的操作         282
8.5 
stack容器      284
8.5.1 
stack及其特点   284
8.5.2 
stack的操作       284
8.5.3 
应用举例：将一个十进制整数转换为K进制数     285
8.6  关联容器        287
8.6.1 
用结构体定义的pair类模板    287
8.6.2 
set和multiset容器   289
8.6.3 
map和multimap容器        293
8.7  知识链接        297
8.7.1 
const_iterator     297
8.7.2 
分配器         298
习题8      299
第4篇  C  深入编程
第9单元  C  实体访问探幽       305
9.1 
C  实体的基本访问属性     305
9.1.1 
变量的生命期与C  存储分配 305
9.1.2 
标识符的作用域与链接性         307
9.2 
C  变量的存储属性     309
9.2.1 
C  的extern关键字 309
9.2.2 
C  的static关键字   313
9.3 
C  名字空间域     320
9.3.1 
名字冲突与名字空间         320
9.3.2 
名字空间的使用         322
9.3.3 
无名名字空间和全局名字空间         324
9.4 
const指针与const引用        325
9.4.1 
const修饰指针  325
9.4.2 
const修饰引用  326
9.4.3 
顶层const与底层const    327
9.5 
C  11的左值引用与右值引用    329
9.5.1 
C  11的左值引用与右值引用的基本概念     329
9.5.2 
基于左值和右值概念的表达式分类         330
9.5.3 
C  引用的扩展及绑定规则      330
9.5.4 
C   11的引用折叠与模板参数推导         333
9.6  智能指针        334
9.6.1 
智能指针及其基本原理    334
9.6.2 
auto_ptr智能指针     335
9.6.3 
Boost库的智能指针  337
习题9      339
第10单元  C  函数探幽     345
10.1 
C  函数调用时的参数匹配规则        345
10.1.1 
C  函数调用时的参数匹配规则    345
10.1.2 
关于函数实参的计算顺序       346
10.1.3 
函数名重载       346
10.1.4 
形参带有默认值的函数  349
10.1.5 
参数数目可变的函数       350
10.2 
参数类型      351
10.2.1 
对象参数  351
10.2.2 
指针参数  353
10.2.3 
数组参数  354
10.2.4 
左值引用参数  356
10.2.5 
const保护函数参数         359
10.2.6 
完美转发  360
10.3 
函数返回      363
10.3.1 
函数返回的基本规则       363
10.3.2 
函数返回指针  363
10.3.3 
函数返回引用  364
10.3.4 
const保护函数返回值     367
10.4 
移动语义      369
10.4.1 
移动语义的提出       369
10.4.2 
移动构造函数与移动赋值操作符  369
10.4.3 
强制移动与std::move()   371
10.5 
Lambda表达式    372
10.5.1 
简单的Lambda表达式    372
10.5.2 
在方括号中加入函数对象参数       373
习题10    375
第11单元  C  I/O流  379
11.1 
流与C  流类       379
11.1.1 
流与缓冲区       379
11.1.2 
C  流类库         380
11.1.3 
ios类声明          381
11.2 
标准流对象与标准I/O流操作  383
11.2.1 
C  标准流对象         383
11.2.2 
标准输入/输出流操作     383
11.3 
流的格式化 383
11.3.1 
ios类的格式化成员函数和格式化标志          384
11.3.2 
格式化操作符  384
11.4 
文件流 385
11.4.1 
文件流的概念及其分类  385
11.4.2 
文件操作过程  386
11.5 
流的错误状态及其处理      389
11.5.1 
流的出错状态  389
11.5.2 
测试与设置出错状态位的ios类成员函数    390
习题11    390
附录A  C  保留字        392
A.1 
C  关键字     392
A.2 
C  替代标记          392
A.3 
C  库保留名称     393
A.4 
C  特定字     393
附录B  C  运算符的优先级别和结合方向        394
附录C  C  标准库与准标准库   396
C.1 
C  标准库头文件          396
C.1.1 
标准库中与语言支持功能相关的头文件         396
C.1.2 
支持流输入/输出的头文件       396
C.1.3 
与诊断功能相关的头文件         397
C.1.4 
定义工具函数的头文件    397
C.1.5 
支持字符串处理的头文件         397
C.1.6 
定义容器类的模板的头文件    397
C.1.7 
支持迭代器的头文件         398
C.1.8 
有关算法的头文件    398
C.1.9 
有关数值操作的头文件    398
C.1.10 
有关本地化的头文件      398
C.2 
C   Boost库内容 398
C.2.1 
字符串和文本处理库         399
C.2.2 
容器库         399
C.2.3 
迭代器库    399
C.2.4 
算法库         400
C.2.5 
函数对象和高阶编程库    400
C.2.6 
泛型编程库         400
C.2.7 
模板元编程         400
C.2.8 
预处理元编程库         401
C.2.9 
并发编程库         401
C.2.10 
数学和数字库  401
C.2.11 
排错和测试库  401
C.2.12 
数据结构库      402
C.2.13 
图像处理库      402
C.2.14 
输入/输出库     402
C.2.15 
跨语言混合编程库  402
C.2.16 
内存管理库      402
C.2.17 
解析库      402
C.2.18 
编程接口库      402
C.2.19 
综合类库  403
C.2.20 
编译器问题的变通方案库      403
参考文献         404
 
 
·VII·
 
 
 
