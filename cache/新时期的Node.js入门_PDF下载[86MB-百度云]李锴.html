新时期的Node.js入门 PDF下载 李锴 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730248780
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730248780
<p>书名:新时期的Node.js入门</p><p>作者:李锴</p><p>页数:279</p><p>定价:¥49.0</p><p>出版社:清华大学出版社</p><p>出版日期:2018-01-01</p><p>ISBN:9787302487807</p><p><h2>本书特色</h2></p>[<p>
Node.js是一门开源的、为Web而生的语言，具有高并发、异步等特点，并且拥有一个十分活跃的开发者社区。与Ruby、Python等语言相比，Node.js更年轻、更易于没有经验的人上手使用，因此很快在世界各地的开发者中收获了一大批拥趸。在国内，Node.js在许多企业中获得了广泛应用，并取得了一系列的应用成果。然而，随着技术的不断更新、ECMAScript2015等新标准纷纷确定，现有的中文书籍就变得有些过时。本书立足于新的技术潮流，介绍了一系列全新的语言特性和标准，以便让读者在学习基础知识的同时紧跟新技术的发展。
本书分为8章6个附录，讲解了Node.js的各种基础特性，使读者快速入门，同时结合语言*的发展趋势，让读者能够紧跟技术潮流。本书围绕Node.js在Web站点开发和爬虫系统中的应用展开，对Node.js在大型项目中的定位与应用做了详细的说明。
本书可用于Node.js入门，适合未接触过Node的读者以及在校的学生阅读，也适合作为高等院校和培训学校相关专业的师生教学参考。
                                        </p>]<p><h2>内容简介</h2></p>[<p>从零开始学习开发完整可用的项目，掌握语言细节并获得实际经验以实际应用为背景，阐述Node.js在实际项目中的定位和潜在的陷阱适合没有Node.js经验的读者，旨在快速上手到独立开发小型应用 </p>]<p><h2>作者简介</h2></p>[<p>李锴，毕业于厦门大学软件学院，目前就职于花旗集团，从事Web前端开发工作。</p>]<p><h2>目录</h2></p>
    目录
 
 
 
第1章  基础知识          1
1.1 
Node是什么  1
1.1.1 
Node与JavaScript      1
1.1.2 
runtime和VM    2
1.2 
Node的内部机制  3
1.2.1 
何为回调    3
1.2.2 
同步/异步和阻塞/非阻塞 4
1.2.3 
单线程和多线程         6
1.2.4 
并行和并发         7
1.3  事件循环（Event
loop）       8
1.3.1 
事件与循环         8
1.3.2 
Node中的事件循环   9
1.3.3 
process.nextTick 13
1.4  总结        16
1.5  参考资源        16
第2章  常用模块          17
2.1 
Module   17
2.1.1 
JavaScript的模块规范        17
2.1.2 
require及其运行机制        18
2.1.3 
require的隐患    20
2.1.4 
模块化与作用域         20
2.2 
Buffer      22
2.2.1 
Buffer的构建与转换 23
2.2.2 
Buffer的拼接      24
2.3 
File System      26
2.4 
HTTP服务      30
2.4.1 
创建HTTP 服务器     30
2.4.2 
处理HTTP请求  32
2.4.3 
Response对象    34
2.4.4 
上传数据    35
2.4.5 
HTTP客户端服务       38
2.4.6 
创建代理服务器         39
2.5 
TCP服务         40
2.5.1 
TCP和Socket      41
2.5.2 
创建TCP服务器         41
2.6  更安全的传输方式——SSL  42
2.6.1 
什么是SSL  43
2.6.2 
SSL原理       43
2.6.3 
对称加密与非对称加密    44
2.6.4 
关于CA       45
2.6.5 
创建HTTPS服务         45
2.7 
WebSocket      48
2.7.1 
保持通话    48
2.7.2 
为什么要有WebSocket      49
2.7.3 
WebSocket与Node    50
2.8 
Stream    50
2.8.1 
Stream 的种类  50
2.8.2 
ReadLine      53
2.8.3 
自定义Stream    54
2.9 
Events     55
2.9.1 
事件和监听器    55
2.9.2 
处理error事件  56
2.9.3 
继承Events模块        57
2.10 
多进程服务 58
2.10.1 
child_process模块   58
2.10.2 
spawn        58
2.10.3 
fork    59
2.10.4 
exec和execFile         60
2.10.5 
各方法之间的比较  62
2.10.6 
进程间通信       64
2.10.7 
Cluster       65
2.11 
Process对象         66
2.11.1 
环境变量  67
2.11.2 
方法和事件       67
2.11.3 
一个例子：修改所在的时区  68
2.12 
Timer    70
2.12.1 
常用API    70
2.12.2 
定时器中的this        71
2.13 
小结      72
2.14 
引用资源      72
第3章  用ES6来书写Node         73
3.1  新时代的EMCAScript   73
3.1.1 
JavaScript的缺陷        73
3.1.2 
Node对新标准的支持       74
3.1.3 
使用nvm管理Node版本 75
3.2  块级作用域   75
3.2.1 
ES5中的作用域 75
3.2.2 
let关键字   77
3.2.3 
const关键字       78
3.3  数组        78
3.3.1 
find()和findIndex()      79
3.3.2 
from()方法  79
3.3.3 
fill()方法       81
3.3.4 
数组的遍历         81
3.3.5 
TypedArray  82
3.4  函数        82
3.4.1 
参数的默认值    82
3.4.2 
Spread运算符    83
3.4.3 
箭头函数    83
3.4.4 
箭头函数的陷阱         86
3.5 
Set和Map     87
3.5.1 
Set和WeakSet   87
3.5.2 
Map和WeakMap       88
3.6 
Iterator  89
3.6.1 
Java中的Iterator       89
3.6.2 
ES6中的Iterator         89
3.6.3 
Iterator的遍历  90
3.7  对象        91
3.7.1 
新的方法    91
3.7.2 
对象的遍历         92
3.8  类   93
3.8.1 
属性和构造函数         94
3.8.2 
类方法         94
3.8.3 
__proto__   95
3.8.4 
静态方法    96
3.9  类的继承        96
3.9.1 
ES5中的继承      96
3.9.2 
ES6中的继承      98
3.9.3 
Node中的类继承       100
3.10 
ES6的模块化标准       101
3.11 
使用babel来转换代码       102
3.12 
小结      106
3.13 
引用资源      106
第4章  书写异步代码          107
4.1  异步操作的返回值        108
4.2  组织回调方法        108
4.2.1 
回调与CPS 108
4.2.2 
使用async模块简化回调 110
4.3  使用Promise 112
4.3.1 
Promise的历史  112
4.3.2 
Promise是什么  113
4.3.3 
ES2015中的Promise 114
4.3.4 
Promise的常用API    116
4.3.5 
使用Promise组织异步代码      119
4.3.6 
第三方模块的Promise       120
4.4 
Generator，一种过渡方案  122
4.4.1 
Generator的使用       122
4.4.2 
Generator函数的执行       123
4.4.3 
Generator中的错误处理  126
4.4.4 
用Generator组织异步方法      127
4.4.5 
Generator的自动执行       128
4.5  回调的终点——async/await        131
4.5.1 
async函数的概念       131
4.5.2 
await关键字       133
4.5.3 
在循环中使用async方法 135
4.5.4 
async和await小结   136
4.5.5 
async 函数的缺点     137
4.6  总结        138
4.7  引用资源        139
第5章  使用Koa2构建Web站点       140
5.1 
Node Web框架的发展历程  140
5.1.1 
Connect       140
5.1.2 
Express        141
5.1.3 
Koa       141
5.2  内容规划        142
5.2.1 
需求分析    142
5.2.2 
技术选型    142
5.3 
Koa入门         143
5.3.1 
Koa1.x 与Koa2  143
5.3.2 
context对象        144
5.4 
middleware    148
5.4.1 
中间件的概念    148
5.4.2 
next方法    150
5.4.3 
中间件的串行调用    151
5.4.4 
一个例子——如何实现超时响应    152
5.5  常用服务的实现   154
5.5.1 
静态文件服务    154
5.5.2 
路由服务    155
5.5.3 
数据存储    156
5.5.4 
文件上传    160
5.5.5 
页面渲染    163
5.6  构建健壮的Web应用  165
5.6.1 
上传文件验证    166
5.6.2 
使用Cookie进行身份验证        167
5.6.3 
使用Session记录会话状态       170
5.7  使用Redis进行持久化          173
5.7.1 
Node和Redis的交互         173
5.7.2 
CURD操作 174
5.7.3 
使用Redis持久化session          176
5.7.4 
Redis在Node中的应用    179
5.8 
Koa源码剖析         180
5.8.1 
Koa的启动过程 180
5.8.2 
中间件的加载    181
5.8.3 
listen()方法 184
5.8.4 
next()与return next() 185
5.8.5 
关于Can't set headers after they are sent.       186
5.8.6 
Context对象的实现  187
5.8.7 
Koa的优缺点      189
5.9  网站部署        190
5.9.1 
本地部署    190
5.9.2 
部署在云服务主机上         191
5.9.3 
通过GitHub pages来部署         193
5.10 
总结      194
5.11 
引用资源      194
第6章  爬虫系统的开发     195
6.1  爬虫技术概述        196
6.2  技术栈简介   196
6.2.1 
request.js    196
6.2.2 
cheerio         197
6.2.3 
消息队列    199
6.3  构建脚手架   199
6.3.1 
选择目标网站    199
6.3.2 
分析URL结构    200
6.3.3 
构建HTTP 请求          200
6.3.4 
解析页面元素    201
6.4  进行批量爬取        203
6.4.1 
使用递归和定时器    203
6.4.2 
多进程并行         205
6.5  爬虫架构的改进   206
6.5.1 
异步流程控制    206
6.5.2 
回到*初的目标         206
6.5.3 
多进程模型的缺陷    208
6.6  进程架构的改进   208
6.6.1 
生产/消费模型   208
6.6.2 
生产者的实现    209
6.6.3 
消费者的实现    211
6.7  反爬虫处理   213
6.7.1 
爬虫的危害         213
6.7.2 
识别一个爬虫    213
6.7.3 
针对爬虫的处理         214
6.8  总结        216
6.9  引用资源        216
第7章  测试与调试     217
7.1  单元测试        218
7.1.1 
使用Assert模块         218
7.1.2 
Jasmine        219
7.1.3 
Ava.js——面向未来  224
7.2  测试现有代码        227
7.3  更高维度的测试   228
7.3.1 
基准测试    228
7.3.2 
集成测试    229
7.3.3 
持续集成    229
7.4  调试Node应用     231
7.4.1 
语言和IDE 232
7.4.2 
使用node-inspector   233
7.4.3 
使用v8-inspector        234
7.4.4 
使用IDE进行调试     236
7.4.5 
cpu profiling         237
7.5  总结        239
7.6  引用资源        239
第8章  Node中的错误处理        240
8.1 
Error模块       241
8.2  错误处理的几种方式   241
8.3  被抛弃的Domain  243
8.3.1 
Domain模块简介       243
8.3.2 
Domain原理       247
8.3.3 
Domain中间件   249
8.3.4 
Domain的缺陷   249
8.4 
ES6中的错误处理          250
8.4.1 
Promise        250
8.4.2 
Generator   250
8.4.3 
async函数  251
8.5 
Web服务中的错误处理        251
8.5.1 
针对每个请求的错误处理         251
8.5.2 
Express中的错误处理       252
8.5.3 
Koa中的错误处理      252
8.6  防御式编程与Let it
crash     253
8.7  总结        256
8.8  引用资源        256
附录A  进程、线程、协程 257
A.1  从操作系统说起   257
A.2 
Node中的协程      258
附录B  Lua语言简介   259
B.1 
Lua中的数据类型         259
B.2  定义一个函数        260
B.3 
Lua中的协程         261
附录C  从零开发一个Node
Web框架        263
C.1  框架的雏形   263
C.2  框架的完善   264
C.3  总结        268
附录D  MongoDB和Redis简介 269
D.1 
NoSQL    269
D.2 
MongoDB简介      269
D.3 
Redis简介     271
附录E  使用Docker来实现虚拟化     274
E.1 
Docker的一些常用命令        274
E.2 
Redis服务      275
附录F  npm与包管理  277
F.1 
package.json常用字段  277
F.2  依赖版本的管理    278
 
