操作系统设计-Xinu方法 PDF下载 (美)DouglasComer著，邹恒明等译 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711142826
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711142826
<p>书名:操作系统设计-Xinu方法</p><p>作者:(美)Douglas Comer　著，邹恒明　等译</p><p>页数:359</p><p>定价:¥79.0</p><p>出版社:机械工业出版社</p><p>出版日期:2014-01-01</p><p>ISBN:9787111428268</p><p><h2>内容简介</h2></p>[<p>
                                    
                                        
　　本书对操作系统的内存管理、进程管理、进程协调和同步、进程间通信、实时时钟管理、设备无关的i/o、设备驱动、网络协议、文件系统等进行了详细的介绍，并利用分层的设计范式，以一种有序、易于理解的方式来阐述这些内容。本书以xinu操作系统为系统设计的样板和模式，从一个裸机开始，一步一步地设计和实现一个小型但优雅的操作系统。本书的样本代码可以运行在linksys
e2100l无线路由器上。
本书适用于高年级的本科生或低年级的研究生，也适用于那些想了解操作系统的计算机从业人员。学习本书前，学生需要具备基本的程序设计能力，应当理解基本的数据结构，包括链表、栈和队列，并且应当用c语言写过程序。                                    </p>]<p><h2>作者简介</h2></p>[<p>
                                    
                                        　　Douglas
Comer　美国普度大学计算机系杰出教授，国际公认的计算机网络、TCP/IP协议、Internet和操作系统设计方面的专家。Comer出版了多部优秀的教材和专著，被翻译成16种语言，并广泛用于世界各地的工业界和学术界。Comer教授划时代的三卷巨著《Internetworking
with TCP/IP》对网络和网络教育产生了革命性的影响。Comer博士是ACM院士、普度教育学院院士。                                    </p>]<p><h2>目录</h2></p>
operating system design：the xinu approach，linksys version出版者的话译者序前言关于作者第1章　引言和概述1　1.1　操作系统1　1.2　本书的研究方法1　1.3　分层设计2　1.4　xinu操作系统3　1.5　操作系统不是什么3　1.6　从外面看操作系统4　1.7　其他章节概要4　1.8　观点5　1.9　总结5　练习5第2章　并发执行与操作系统服务6　2.1　引言6　2.2　多活动的编程模型6　2.3　操作系统服务7　2.4　并发处理的概念和术语7　2.5　串行程序和并发程序的区别8　2.6　多进程共享同一段代码9　2.7　进程退出与进程终止11　2.8　共享内存、竞争条件和同步11　2.9　信号量与互斥14　2.10　xinu中的类型命名方法15　2.11　使用kputc和kprintf进行操作系统的调试16　2.12　观点16　2.13　总结16　练习17第3章　硬件和运行时环境概览18　3.1　引言18　3.2　e2100l的物理和逻辑结构18　3.3　处理器结构和寄存器19　3.4　总线操作：获取-存储范式19　3.5　直接内存访问19　3.6　总线地址空间20　3.7　内核段kseg0和kseg1的内容20　3.8　总线启动的静态配置21　3.9　调用约定和运行时栈21　3.10　中断和中断处理22　3.11　异常处理23　3.12　计时器硬件23　3.13　串行通信24　3.14　轮询与中断驱动i/o24　3.15　内存缓存和kseg124　3.16　存储布局24　3.17　内存保护25　3.18　观点25　练习25第4章　链表与队列操作26　4.1　引言26　4.2　用于进程链表的统一数据结构26　4.3　简洁的链表数据结构27　4.4　队列数据结构的实现28　4.5　内联队列操作函数29　4.6　获取链表中进程的基础函数29　4.7　fifo队列操作30　4.8　优先级队列的操作32　4.9　链表初始化33　4.10　观点34　4.11　总结34　练习35第5章　调度和上下文切换36　5.1　引言36　5.2　进程表36　5.3　进程状态38　5.4　就绪和当前状态38　5.5　调度策略38　5.6　调度的实现39　5.7　上下文切换的实现41　5.8　内存中保存的状态41　5.9　在mips处理器上切换上下文41　5.10　重新启动进程执行的地址43　5.11　并发执行和null进程44　5.12　使进程准备执行和调度不变式44　5.13　推迟重新调度45　5.14　其他进程调度算法47　5.15　观点47　5.16　总结47　练习47第6章　更多进程管理49　6.1　引言49　6.2　进程挂起和恢复49　6.3　自我挂起和信息隐藏49　6.4　系统调用的概念50　6.5　禁止中断和恢复中断51　6.6　系统调用模板51　6.7　系统调用返回syserr和ok值51　6.8　挂起的实现52　6.9　挂起当前进程53　6.10　suspend函数的返回值53　6.11　进程终止和进程退出54　6.12　进程创建56　6.13　其他进程管理函数59　6.14　总结60　练习61第7章　协调并发进程62　7.1　引言62　7.2　进程同步的必要性62　7.3　计数信号量的概念63　7.4　避免忙等待63　7.5　信号量策略和进程选择63　7.6　等待状态64　7.7　信号量数据结构64　7.8　系统调用wait65　7.9　系统调用signal66　7.10　静态和动态信号量分配66　7.11　动态信号量的实现示例67　7.12　信号量删除68　7.13　信号量重置69　7.14　多核处理器之间的协调69　7.15　观点70　7.16　总结70　练习71第8章　消息传递72　8.1　引言72　8.2　两种类型的消息传递服务72　8.3　消息使用资源的限制72　8.4　消息传递函数和状态转换73　8.5　send的实现73　8.6　receive的实现74　8.7　非阻塞消息接收的实现75　8.8　观点75　8.9　总结75　练习76第9章　基本内存管理77　9.1　引言77　9.2　内存的类型77　9.3　重量级进程的定义77　9.4　小型嵌入式系统的内存管理78　9.5　程序段和内存区域78　9.6　嵌入式系统中的动态内存分配79　9.7　低层内存管理器的设计79　9.8　分配策略和内存持久性80　9.9　追踪空闲内存80　9.10　低层内存管理的实现80　9.11　分配堆存储82　9.12　分配栈存储83　9.13　释放堆和栈存储84　9.14　观点86　9.15　总结87　练习87第10章　高级内存管理和虚拟内存88　10.1　引言88　10.2　分区空间分配88　10.3　缓冲池88　10.4　分配缓冲区89　10.5　将缓冲区返回给缓冲池90　10.6　创建缓冲池91　10.7　初始化缓冲池表93　10.8　虚拟内存和内存复用93　10.9　实地址空间和虚地址空间93　10.10　支持按需换页的硬件94　10.11　使用页表的地址翻译95　10.12　页表项中的元数据95　10.13　按需换页以及设计上的问题95　10.14　页面替换和全局时钟算法96　10.15　观点97　10.16　总结97　练习97第11章　高层消息传递98　11.1　引言98　11.2　进程间通信端口98　11.3　端口实现98　11.4　端口表初始化99　11.5　端口创建100　11.6　向端口发送消息101　11.7　从端口接收消息102　11.8　端口的删除和重置103　11.9　观点106　11.10　总结106　练习106第12章　中断处理107　12.1　引言107　12.2　中断的优点107　12.3　中断分配107　12.4　中断向量107　12.5　中断向量号的分配108　12.6　硬件中断108　12.7　中断请求的局限性和中断多路复用109　12.8　中断软件和分配109　12.9　中断分配器底层部分110　12.10　中断分配器高层部分112　12.11　禁止中断114　12.12　函数中中断代码引起的限制115　12.13　中断过程中重新调度的必要性115　12.14　中断过程中的重新调度115　12.15　观点116　12.16　总结116　练习117第13章　实时时钟管理118　13.1　引言118　13.2　定时事件118　13.3　实时时钟和计时器硬件118　13.4　处理实时时钟中断119　13.5　延时与抢占119　13.6　使用计时器来模拟实时时钟120　13.7　抢占的实现120　13.8　使用增量链表对延迟进行有效管理120　13.9　增量链表的实现121　13.10　将进程转入睡眠122　13.11　定时消息接收124　13.12　唤醒睡眠进程127　13.13　时钟中断处理127　13.14　时钟初始化128　13.15　间隔计时器管理129　13.16　观点130　13.17　总结130　练习130第14章　设备无关的i/o132　14.1　引言132　14.2　i/o和设备驱动的概念结构132　14.3　接口抽象和驱动抽象133　14.4　i/o接口的一个示例134　14.5　打开-读-写-关闭范式134　14.6　绑定i/o操作和设备名134　14.7　xinu中的设备名135　14.8　设备转换表概念135　14.9　设备和共享驱动的多个副本136　14.10　高层i/o操作的实现138　14.11　其他高层i/o函数138　14.12　打开、关闭和引用计数141　14.13　devtab中的空条目和错误条目143　14.14　i/o系统的初始化143　14.15　观点146　14.16　总结147　练习147第15章　设备驱动示例148　15.1　引言148　15.2　tty抽象148　15.3　tty设备驱动的组成149　15.4　请求队列和缓冲区149　15.5　上半部和下半部的同步150　15.6　硬件缓冲区和驱动设计151　15.7　tty控制块和数据声明151　15.8　次设备号153　15.9　上半部tty字符输入（ttygetc）153　15.10　通用上半部tty输入（ttyread）154　15.11　上半部tty字符输出（ttyputc）155　15.12　开始输出（ttykickout）156　15.13　上半部tty多字符输出（ttywrite）157　15.14　下半部tty驱动函数（ttyinterrupt）157　15.15　输出中断处理（ttyinter_out）159　15.16　tty输入处理(tty inter-in)161　15.17　tty控制块初始化（ttyinit）166　15.18　设备驱动控制168　15.19　观点169　15.20　总结169　练习169第16章　dma设备和驱动（以太网）171　16.1　引言171　16.2　直接内存访问和缓冲区171　16.3　多缓冲区和环171　16.4　使用dma的以太网驱动例子172　16.5　设备的硬件定义和常量172　16.6　环和内存缓冲区174　16.7　以太网控制块的定义175　16.8　设备和驱动初始化177　16.9　分配输入缓冲区181　16.10　从以太网设备中读取数据包182　16.11　向以太网设备中写入数据包183　16.12　以太网设备的中断处理185　16.13　以太网控制函数187　16.14　观点189　16.15　总结189　练习189第17章　*小互联网协议栈190　17.1　引言190　17.2　所需的功能190　17.3　同步对话、超时和进程191　17.4　arp函数192　17.5　网络数据包的定义198　17.6　网络输入进程199　17.7　udp表的定义202　17.8　udp函数203　17.9　互联网控制报文协议210　17.10　动态主机配置协议211　17.11　观点214　17.12　总结214　练习214第18章　远程磁盘驱动215　18.1　引言215　18.2　磁盘抽象215　18.3　磁盘操作驱动支持215　18.4　块传输和高层i/o函数215　18.5　远程磁盘范式216　18.6　磁盘操作的语义216　18.7　驱动数据结构的定义217　18.8　驱动初始化（rdsinit）221　18.9　上半部打开函数（rdsopen）223　18.10　远程通信函数（rdscomm）224　18.11　上半部写函数（rdswrite）226　18.12　上半部读函数（rdsread）228　18.13　刷新挂起的请求231　18.14　上半部控制函数（rdscontrol）231　18.15　分配磁盘缓冲区（rdsbufalloc）233　18.16　上半部关闭函数（rdsclose）234　18.17　下半部通信进程（rdsprocess）235　18.18　观点239　18.19　总结239　练习240第19章　文件系统241　19.1　文件系统是什么241　19.2　文件操作的示例集合241　19.3　本地文件系统的设计242　19.4　xinu文件系统的数据结构242　19.5　索引管理器的实现243　19.6　清空索引块（lfibclear）246　19.7　获取索引块（lfibget）247　19.8　存储索引块（lfibput）247　19.9　从空闲链表中分配索引块（lfiballoc）248　19.10　从空闲链表中分配数据块（lfdballoc）249　19.11　使用设备无关的i/o函数的文件操作250　19.12　文件系统的设备设置和函数名称251　19.13　本地文件系统打开函数（lfsopen）251　19.14　关闭文件伪设备（lflclose）256　19.15　刷新磁盘中的数据（lfflush）256　19.16　文件的批量传输函数（lflwrite,lflread）257　19.17　在文件中查找一个新位置（lflseek）258　19.18　从文件中提取一个字节（lflgetc）259　19.19　改变文件中的一个字节（lflputc）260　19.20　载入索引块和数据块（lfsetup）261　19.21　主文件系统设备的初始化（lfsinit）264　19.22　伪设备的初始化（lflinit）264　19.23　文件截断（lftruncate）265　19.24　初始文件系统的创建（lfscreate）267　19.25　观点269　19.26　总结269　练习269第20章　远程文件机制270　20.1　引言270　20.2　远程文件访问270　20.3　远程文件语义270　20.4　远程文件设计和消息271　20.5　远程文件服务器通信276　20.6　发送一个基本消息278　20.7　网络字节序279　20.8　使用设备范式的远程文件系统279　20.9　打开远程文件280　20.10　检查文件模式282　20.11　关闭远程文件283　20.12　读远程文件284　20.13　写远程文件286　20.14　远程文件的定位288　20.15　远程文件单字符i/o288　20.16　远程文件系统控制函数289　20.17　初始化远程文件数据结构292　20.18　观点293　20.19　总结293　练习294第21章　句法名字空间295　21.1　引言295　21.2　透明与名字空间的抽象295　21.3　多种命名方案295　21.4　命名系统设计的其他方案296　21.5　基于句法的名字空间296　21.6　模式和替换297　21.7　前缀模式297　21.8　名字空间的实现297　21.9　名字空间的数据结构和常量297　21.10　增加名字空间前缀表的映射298　21.11　使用前缀表进行名字映射299　21.12　打开命名文件302　21.13　名字空间初始化303　21.14　对前缀表中的项进行排序305　21.15　选择一个逻辑名字空间305　21.16　默认层次和空前缀305　21.17　额外的对象操作函数306　21.18　名字空间方法的优点和限制306　21.19　广义模式307　21.20　观点307　21.21　总结308　练习308第22章　系统初始化309　22.1　引言309　22.2　引导程序：从头开始309　22.3　操作系统初始化309　22.4　在e2100l上启动一个可选的映像310　22.5　xinu初始化310　22.6　系统启动312　22.7　从程序转化为进程316　22.8　观点316　22.9　总结316　练习316第23章　异常处理317　23.1　引言317　23.2　异常、陷阱和恶意中断317　23.3　panic的实现317　23.4　观点318　23.5　总结318　练习318第24章　系统配置319　24.1　引言319　24.2　多重配置的需求319　24.3　xinu系统配置319　24.4　xinu配置文件的内容320　24.5　计算次设备号321　24.6　配置xinu系统的步骤322　24.7　观点322　24.8　总结322　练习322第25章　一个用户接口例子：xinu壳323　25.1　引言323　25.2　用户接口323　25.3　命令和设计原则323　25.4　一个简化壳的设计决策324　25.5　壳的组织和操作324　25.6　词法符号的定义324　25.7　命令行语法的定义325　25.8　xinu壳的实现325　25.9　符号的存储327　25.10　词法分析器代码327　25.11　命令解释器的核心330　25.12　命令名查询和内部处理336　25.13　传给命令的参数336　25.14　向外部命令传递参数337　25.15　i/o重定向339　25.16　示例命令函数（sleep）340　25.17　观点341　25.18　总结341　练习342附录1　操作系统移植343附录2　xinu设计注解349索引352                            
